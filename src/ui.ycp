/**
 * File:
 *   include/restore/ui.ycp
 *
 * Package:
 *   Restore module
 *
 * Summary:
 *   User interface functions.
 *
 * Authors:
 *   Ladislav Slezak <lslezak@suse.cz>
 *
 * $Id$
 *
 * All user interface functions.
 *
 */

{

textdomain "restore";

import "Wizard";
import "Wizard_hw";
import "Progress";
import "Restore";
import "Mode";

include "ui/common_popups.ycp";
include "ui/common_messages.ycp";
include "ui/file_popups.ycp";
include "wizard/sequencer.ycp";

include "restore/helps.ycp";
include "restore/summary_dialog.ycp";


global string restorepackagename = nil;

global list archivecontentscache = nil;

/**
 * Whole configuration of restore
 * @return any Returned value from WizardSequencer() call
 */
global define any RestoreSequence () ``{
    map aliases =
	$[
	    "archive"	:   ``( ArchiveSelectionDialog() ),
	    "property"	:   ``( ArchivePropertyDialog() ),
	    "contents"	: [ ``( ArchiveContentsDialog() ), true ],
	    "options"	: [ ``( RestoreOptionsDialog() ), true ],
	    "install"	:   ``( SelectionInstallDialog() ),
	    "uninstall"	:   ``( SelectionUninstallDialog() ),
	    "sw_single"	:   ``( SWsingleDialog() ),
	    "select"	:   ``( PackageSelectionRestoreDialog() ),
	    "selectfile": [ ``( FileSelectionDialog(restorepackagename) ), true ],
	    "restore"	: [ ``( RestoreProgressDialog() ), true ],
	    "SuSEconfig": [ ``( SuSEconfigDialog() ), true ],
	    "summary"	:   ``( SummaryDialog() ),
	];

    map sequence = $[
	"ws_start" : "archive",
//	"ws_start" : "select",
	"archive" :
	$[
	    `options	: "options",
	    `next	: "property",
	    `abort	: `abort
	],
	"property" :
	$[
	    `details	: "contents",
	    `next	: "install",
	    `abort	: `abort
	],
	"contents" :
	$[
	    `next	: "property",
	    `abort	: `abort
	],
	"options" :
	$[
	    `next	: "archive",
	    `abort	: `abort
	],
	"install" :
	$[
	    `next	: "uninstall",
	    `abort	: `abort
	],
	"uninstall" :
	$[
	    `next	: "sw_single",
	    `abort	: `abort
	],
	"sw_single" :
	$[
	    `next	: "select",
	    `abort	: `abort
	],
	"select" :
	$[
	    `files	: "selectfile",
	    `abort	: `abort,
	    `next	: "restore"
	],
	"restore" :
	$[
	    `next	: "SuSEconfig",
	    `abort	: `abort
	],
	"SuSEconfig" :
	$[
	    `next	: "summary",
	    `abort	: `abort
	],
	"selectfile" :
	$[
	    `next	: "select",
	    `abort	: `abort
	],
	"summary" :
	$[
	    `abort	: `abort,
	    `next	: `next
	]
    ];

    string caption = _("Restore configuration");
    term contents = `Label (_("Initializing ..."));

    Wizard::CreateDialog ();
    Wizard::SetContentsButtons ( caption,
				contents,
				"",
				BackButtonLabel (),
				NextButtonLabel ());

    any ret = WizardSequencer (aliases, sequence);

    UI::CloseDialog ();
    return ret;
}

/**
 * Whole configuration of restore but without reading and writing.
 * For use with autoinstallation.
 * @return any Returned value from WizardSequencer() call
 */
global define any RestoreAutoSequence () ``{
    string caption = _("Restore configuration");
    term contents = `Label (_("Initializing ..."));

    Wizard::CreateDialog ();
    Wizard::SetContentsButtons ( caption,
				contents,
				"",
				BackButtonLabel (),
				NextButtonLabel ());

    // Run the main configuration workflow
    any ret = MainSequence ();

    UI::CloseDialog ();
    return ret;
}




global define symbol ArchiveSelectionDialog() ``{

    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`HBox(
		    `TextEntry(`id(`filename), _("Archive file na&me:"), "/tmp/bk.tar"),
		    `HSpacing(2),
		    `PushButton(`id(`file), _("&Select file"))
		),
		`VSpacing(2),
		`PushButton(`id(`options), _("R&estore options...")),
		`VSpacing(1.5)
	    ),
	    `HSpacing(2)
	);

    Wizard::SetContents(_("Archive selection"),
	contents, "help", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();

	if (ret == `file)
	{
	    string file = PopupFile("/tmp/backup.tar");

	    /* TODO: check file name */

	    UI::ChangeWidget(`id(`filename), `Value, file);
	}
    }
    while(ret != `next && ret != `abort && ret != `back && ret != `options);

    if (ret == `cancel)
    {
	ret = `abort;
    }

    string fname = (Mode::test != true) ? UI::QueryWidget(`id(`filename), `Value) : "/tmp/testmodearchivename.tar";

    if (ret == `next && fname != Restore::GetArchiveName())
    {
	Wizard::SetContents("", `Label(_("Reading archive contents...")), _("Please wait"), false, false);
	Restore::ReadArchiveFile(fname);
    }

    return ret;
}



global define symbol ArchivePropertyDialog() ``{

    y2milestone("missing packages %1: ", Restore::GetMissingPackages());
    y2milestone("extra packages %1: ", Restore::GetExtraPackages());
    y2milestone("mismatched packages %1: ", Restore::GetMismatchedPackages());

    string date = Restore::GetArchiveDate();
    string hostname = Restore::GetArchiveHostname();
    string comment = Restore::GetArchiveComment();
    string archname = Restore::GetArchiveName();

    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`VSpacing(1),
		`Left(`HBox(`Label(`id(`flabel), _("Archive file name:")), `HSpacing(2), `Label(`id(`flabel2), archname))),
		`VSpacing(0.5),
		`Left(`HBox(`Label(`id(`dlabel), _("Date of backup:")), `HSpacing(2), `Label(`id(`dlabel2), date))),
		`VSpacing(0.5),
		`Left(`HBox(`Label(`id(`hlabel), _("Backup host name:")), `HSpacing(2), `Label(`id(`hlabel2), hostname))),
		`VSpacing(1.0),
		`MultiLineEdit(`id(`description), `opt(`disabled), _("Archive &description:"), comment),
		`VSpacing(1.0),
		`PushButton(`id(`details), _("&Show archive contents...")),
		`VSpacing(2)
	    ),
	    `HSpacing(2)
	);

    Wizard::SetContents(_("Archive properties"),
	contents, "help", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();

    }
    while(ret != `next && ret != `abort && ret != `back && ret != `details);

    if (ret == `cancel)
    {
	ret = `abort;
    }

    return ret;
}

global define list CreateTableContents(map contents, boolean defaultval) ``{
    list ret = [];
    integer num = 0;

    string defval = (defaultval) ? "X" : " ";

    if (contents != nil)
    {
	foreach(string p, map m, contents, ``{

		string ver = lookup(m, "ver", "");
		string descr = lookup(m, "descr", "");

		ret = add(ret, `item(`id(num), defval, p, ver, descr));
		num = num + 1;
	    }
	);
    }

    return ret;
}


global define list CreateTableContentsWithMismatched(map contents, boolean defaultval) ``{
    list ret = [];
    integer num = 0;

    string defval = (defaultval) ? "X" : " ";

    if (contents != nil)
    {
	foreach(string p, map m, contents, ``{

		string ver = lookup(m, "ver", "");
		string descr = lookup(m, "descr", "");
		string installed = lookup(m, "inst", "");

		ret = add(ret, `item(`id(num), defval, p, ver, installed, descr));
		num = num + 1;
	    }
	);
    }

    return ret;
}

global define symbol SelectionInstallDialog() ``{

    // LATER: if all packages are installed return `next (or `back)

    map missingpackages = Restore::GetMissingPackages();

    // add mismatched packages
    foreach(string p, map info, Restore::GetMismatchedPackages(), ``{
	    missingpackages = add(missingpackages, p, info);
	}
    );

    list missing = CreateTableContentsWithMismatched(missingpackages, true);
    string widgetlabel = _("&Packages which will be installed");
    term header = `header(" ", _("Package"), _("Backup version"), _("Installed version"), _("Description"));

    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`VSpacing(1),
		`Table(`id(`pkg), `opt(`notify), header, missing),
		`VSpacing(1),
		`HBox(
		    `PushButton(`id(`all), "&Select all"),
		    `PushButton(`id(`none), "&Deselect all")
		),
		`VSpacing(1.5)
	    ),
	    `HSpacing(2)
	);

    Wizard::SetContents(_("Package restoration - installation"), contents, "help", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();

	if (ret == `all)
	{
	    UI::ChangeWidget(`id(`pkg), `Items, CreateTableContentsWithMismatched(missingpackages, true));
	}
	else if (ret == `none)
	{
	    UI::ChangeWidget(`id(`pkg), `Items, CreateTableContentsWithMismatched(missingpackages, false));
	}
	else if (ret == `pkg)
	{
	    integer current = UI::QueryWidget(`id(`pkg), `CurrentItem);
	    string current_value = select(UI::QueryWidget(`id(`pkg), `Item(current)), 1, " ");

	    if (current_value == " ")
	    {
		current_value = "X";
	    }
	    else
	    {
		current_value = " ";
	    }

	    UI::ChangeWidget(`id(`pkg), `Item(current, 0), current_value);
	}
	else if (ret == `cancel)
	{
	    ret = `abort;
	}
    }
    while (ret != `next && ret != `abort && ret != `back);

    if (ret != `abort)
    {
	integer num = size(missingpackages);
	integer i = 0;
	map selected = $[];

	while (i < num)
	{
	    string s = select(UI::QueryWidget(`id(`pkg), `Item(i)), 1, " ");
	    string p = select(UI::QueryWidget(`id(`pkg), `Item(i)), 2, " ");

	    if (s == "X")
	    {
		map i = lookup(missingpackages, p, $[]);
		string v = lookup(i, "ver", "");
		selected = add(selected, p, $[ "ver" : v ]);
	    }

	    i = i + 1;
	}

	y2milestone("Selected packages to install: %1", selected);
    }

    // TODO: warn if some packages are not available on CDs and display path selection dialog to packages
    // LATER: allow to select package from backup archive (YOU stores packages to /var/... and they can be used)

    return ret;
}


global define symbol SelectionUninstallDialog() ``{

    // LATER: if all packages are installed return `next (or `back)

    map extrapackages = Restore::GetExtraPackages();
    list extra = CreateTableContents(extrapackages, true);

    string widgetlabel = _("&Packages which will be uninstalled");

    term header = `header(" ", _("Package"), _("Version"), _("Description"));

    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`VSpacing(1),
		`Table(`id(`pkg), `opt(`notify), header, extra),
		`VSpacing(1),
		`HBox(
		    `PushButton(`id(`all), "&Select all"),
		    `PushButton(`id(`none), "&Deselect all")
		),
		`VSpacing(1.5)
	    ),
	    `HSpacing(2)
	);

    Wizard::SetContents(_("Package restoration - uninstallation"), contents, "help", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();

	if (ret == `all)
	{
	    UI::ChangeWidget(`id(`pkg), `Items, CreateTableContents(extrapackages, true));
	}
	else if (ret == `none)
	{
	    UI::ChangeWidget(`id(`pkg), `Items, CreateTableContents(extrapackages, false));
	}
	else if (ret == `pkg)
	{
	    integer current = UI::QueryWidget(`id(`pkg), `CurrentItem);
	    string current_value = select(UI::QueryWidget(`id(`pkg), `Item(current)), 1, " ");

	    if (current_value == " ")
	    {
		current_value = "X";
	    }
	    else
	    {
		current_value = " ";
	    }

	    UI::ChangeWidget(`id(`pkg), `Item(current, 0), current_value);
	}
	else if (ret == `cancel)
	{
	    ret = `abort;
	}
    }
    while (ret != `next && ret != `abort && ret != `back);

    if (ret != `abort)
    {
	integer num = size(extrapackages);
	integer i = 0;
	map selected = $[];

	while (i < num)
	{
	    string s = select(UI::QueryWidget(`id(`pkg), `Item(i)), 1, " ");
	    string p = select(UI::QueryWidget(`id(`pkg), `Item(i)), 2, " ");

	    if (s == "X")
	    {
		map i = lookup(extrapackages, p, $[]);
		string v = lookup(i, "ver", "");
		selected = add(selected, p, $[ "ver" : v ]);
	    }

	    i = i + 1;
	}

	y2milestone("Selected packages to uninstall: %1", selected);
    }

    return ret;
}

global define symbol PackageSelectionRestoreDialog() ``{
    // TODO: read this value from system
    boolean profi = true;

    // TODO test distribution: in personal version button = `Empty() and help text will be shorter
    term button = (profi) ? `PushButton(`id(`files), _("S&elect files")) : `Empty();

    string help_profi = "To select files which will be restored from archive press <B>Select files</B> button.";

    list tablecontents = CreateTableContentsRestoreSelection(Restore::GetArchiveInfo(), Restore::GetActualInstalledPackages());
    integer position = 0;

    // refresh previous selection
    if (restorepackagename != nil)
    {
	foreach(term t, tablecontents, ``{
		if (restorepackagename == select(t, 3, ""))
		{
		    position = select(select(t, 0, `id(0)), 0, 0);
		}
	    }
	);
    }

    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`VSpacing(1),
		`Table(`id(`pkgtable),`opt(`notify), `header(" ", _("Files"), _("Package"), _("Version"), _("Description")), tablecontents
		//CreateTableContentsRestoreSelection(Restore::GetArchiveInfo(), Restore::GetActualInstalledPackages())

/*		[ `item(`id(1), "X", "all", "aaa_base-2.4.1-45", "Basic package"),
		    `item(`id(2), "P", "2 of 3", "yast2-base-2.6.2-32", "Yast basic package"), `item(`id(3), "", "", "sysconfig-base-2.6.1-2", "System configuration files")
		]*/),
		`VSpacing(0.2),
		`HBox(`PushButton(`id(`select), _("&Select all")), `PushButton(`id(`deselect), _("&Deselect all")), button),
		`VSpacing(1.5)
	    ),
	    `HSpacing(2)
	);

    Wizard::SetContents(_("Packages to restore"),
	contents, "X = Restore all files from backup, P = Partiall restore of manually selected files", true, true);

    // set currnet item in the table
    if (size(tablecontents) > 0)
    {
	UI::ChangeWidget(`id(`pkgtable), `CurrentItem, position);
    }


    // TODO: display warning if some packages are not installed

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();

	integer current = 0;
	string current_value = "";
	string current_pkgname = "";

	if (size(tablecontents) > 0)
	{
	    current = UI::QueryWidget(`id(`pkgtable), `CurrentItem);
	    current_value = select(UI::QueryWidget(`id(`pkgtable), `Item(current)), 1, " ");
	    current_pkgname = select(UI::QueryWidget(`id(`pkgtable), `Item(current)), 3, "");
	}

	restorepackagename = current_pkgname;

	if (current_pkgname == _("<none>"))
	{
	    current_pkgname = "";
	}

	if (ret == `pkgtable)
	{
	    // toggle restore selection: "X" -> " ", " " -> "X", "P" -> " "
	    if (current_value == " ")
	    {
		current_value = "X";
	    }
	    else
	    {
		current_value = " ";
	    }

	    string selectionstring = (current_value == "X") ? _("all") : "";

	    UI::ChangeWidget(`id(`pkgtable), `Item(current, 0), current_value);
	    UI::ChangeWidget(`id(`pkgtable), `Item(current, 1), selectionstring);

	    Restore::SetRestoreSelection(current_pkgname, $["sel_type" : current_value]);
	}
	else if (ret == `files)
	{
	    restorepackagename = current_pkgname;
	}
	else if ((ret == `select || ret == `deselect) && size(tablecontents) > 0)
	{
	    // set selection type
	    string sel_type = (ret == `select) ? "X" : " ";

	    // set selection type for all packages
	    foreach(string p, map info, Restore::GetArchiveInfo(), ``{
		    Restore::SetRestoreSelection(p, $["sel_type" : sel_type, "sel_file" : []]);
		}
	    );

	    // change table contents
	    UI::ChangeWidget(`id(`pkgtable), `Items, CreateTableContentsRestoreSelection(Restore::GetArchiveInfo(), Restore::GetActualInstalledPackages()));

	    // set previous selection
	    if (current != nil)
	    {
		UI::ChangeWidget(`id(`pkgtable), `CurrentItem, current);
	    }
	}
	else if (ret == `cancel)
	{
	    ret = `abort;
	}
    }
    while (ret != `next && ret != `abort && ret != `back && ret != `files);

    if (ret == `next)
    {
	map final = Restore::GetArchiveInfo();

	final = filter(string p, map i, final, ``{
		return (lookup(i, "sel_type", " ") != " ");
	    }
	);

	y2debug("Final restore selection: %1", final);
    }

    return ret;
}


global define symbol RestoreOptionsDialog() ``{
    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`VSpacing(1),
		`Left(`CheckBox(`id(`lilo), _("Run &lilo after restoration"), Restore::runlilo)),
		`VSpacing(0.2),
		`Left(`CheckBox(`id(`susecfg), _("Run &SuSEconfig after restoration"), Restore::runSuSEconfig)),
		`VSpacing(0.2),
		`Left(`CheckBox(`id(`rpmdb), _("Rewrite RPM &database"), Restore::restoreRPMdb)),
		`VSpacing(1.5)
	    ),
	    `HSpacing(2)
	);

    Wizard::ReplaceNextButton(`PushButton(`id(`next), `opt(`default), OKButtonLabel()));

    Wizard::SetContents(_("Restore options"), contents, "help", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();
    }
    while(ret != `next && ret != `abort && ret != `back);

    if (ret == `cancel)
    {
	ret = `abort;
    }
    else
    {
	Restore::runlilo = UI::QueryWidget(`id(`lilo), `Value);
	Restore::runSuSEconfig = UI::QueryWidget(`id(`susecfg), `Value);
	Restore::restoreRPMdb = UI::QueryWidget(`id(`rpmdb), `Value);
    }

    Wizard::RestoreNextButton();

    return ret;
}

// uses global variable string restorepackagename
global define symbol FileSelectionDialog(string packagename) ``{

    // create multiselection widget contents

    map pkginfo = lookup(Restore::GetArchiveInfo(), packagename, $[]);

    string sel_type = lookup(pkginfo, "sel_type", " ");
    list files = lookup(pkginfo, "files", []);
    list sel_file = lookup(pkginfo, "sel_file", []);

    list cont = [];

    foreach(string f, files, ``{
	    boolean selected = false;

	    if (sel_type == "X")
	    {
		selected = true;
	    }
	    else if (sel_type == " ")
	    {
		selected = false;
	    }
	    else if (sel_type == "P")
	    {
		selected = contains(sel_file, f);
	    }
	    else
	    {
		y2error("Unknown selection type %1 in package %2", sel_type, packagename);
	    }

	    cont = add(cont, `item(`id(f), f, selected));
	}
    );

    string mlabel = _("&Files to restore");

    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`VSpacing(1),
		`ReplacePoint(`id(`rp), `MultiSelectionBox(`id(`mbox), mlabel, cont)),

/*		 [ `item(`id(1), "/usr/blah/blah.cfg", true),
		    `item(`id(2), "/etc/sysconfig/qwerty", true)
		]*/
		`VSpacing(1),
		`HBox(
		    `PushButton(`id(`all), "&Select all"),
		    `PushButton(`id(`none), "&Deselect all")
		),
		`VSpacing(1.5)
	    ),
	    `HSpacing(2)
	);

    Wizard::ReplaceNextButton(`PushButton(`id(`next), `opt(`default), OKButtonLabel()));

    // for translatores: %1 is name of package (e.g. "aaa_base")
    Wizard::SetContents(sformat(_("File selection - package %1"), packagename), contents, "help", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();

	if (ret == `all || ret == `none)
	{
	    cont = [];
	    boolean selected = (ret == `all);

	    foreach(string f, files, ``{
		    cont = add(cont, `item(`id(f), f, selected));
		}
	    );

	    UI::ReplaceWidget(`id(`rp), `MultiSelectionBox(`id(`mbox), mlabel, cont));
	}
	else if (ret == `cancel)
	{
	    ret = `abort;
	}
    }
    while(ret != `next && ret != `abort && ret != `back);

    if (ret == `next)
    {
	string sel_type_new = "";
	// TODO save changes
	list sel = UI::QueryWidget(`id(`mbox), `SelectedItems);

	if (size(sel) == 0)
	{
	    sel_type_new = " ";
	}
	else if (size(sel) == size(files))
	{
	    sel_type_new = "X";
	    // clear list of selected files to save memory, "X" as sel_type is enough
	    sel = [];
	}
	else
	{
	    sel_type_new = "P";
	}

	Restore::SetRestoreSelection(packagename, $["sel_type" : sel_type_new, "sel_file" : sel]);
    }

    Wizard::RestoreNextButton();

    return ret;
}


global define symbol ArchiveContentsDialog() ``{

    Wizard::ClearContents();

    if (archivecontentscache == nil)
    {
	archivecontentscache = CreateArchiveContentTable(Restore::GetArchiveInfo());
    }

    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`VSpacing(1),

		`Table(`id(`table), `header(_("Package"), _("File")), archivecontentscache
		/*[ `item(`id(1), "/dsf/fsdfsdf", "aaa_base-2.4.1-45"), `item(`id(2), "/qert/ret/erqt", "aaa_base-2.4.1-45"),
		    `item(`id(3),  "/adfg/dafg/hg", "yast2-base-2.6.2-32"), `item(`id(4), "/gfh/sg/gsfh/gh", "sysconfig-base-2.6.1-2")
		]*/),
		`VSpacing(1.5)
	    ),
	    `HSpacing(2)
	);

    Wizard::ReplaceNextButton(`PushButton(`id(`next), `opt(`default), OKButtonLabel()));

    Wizard::SetContents(_("Archive contents"), contents, "help", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();
    }
    while(ret != `next && ret != `abort && ret != `back);

    if (ret == `cancel)
    {
	ret = `abort;
    }

    Wizard::RestoreNextButton();

    return ret;
}

global define symbol RestoreProgressDialog() ``{

    map restore = Restore::GetArchiveInfo();
    integer total = 0;
    integer restored = 0;

    // FIXME: set to "/";
    string targetdir = "/tmp/restore";

    // filter out unselected packages and compute total restored files
    restore = filter(string p, map info, restore, ``{
	    string sel_type = lookup(info, "sel_type", " ");

	    if (sel_type == "X")
	    {
		total = total + size(lookup(info, "files", []));
		return true;
	    }
	    else if (sel_type == "P")
	    {
		total = total + size(lookup(info, "sel_file", []));
		return true;
	    }
	    else
	    {
		return false;
	    }
	}
    );

    y2milestone("%1 files will be restored from archive", total);

    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`VSpacing(1),
		`ProgressBar(`id(`progress), " ", total, 0),
		`VSpacing(1.5)
	    ),
	    `HSpacing(2)
	);

    Wizard::SetContents(_("Restoring files"), contents, "help", true, true);

    string tmp = SCR::Read(.target.tmpdir);
    list arch_cont = Restore::GetArchiveFiles();

    foreach(string package, map info, restore, ``{
	    string label = (package == "") ? _("Restoring files not owned by any package ...") : sformat(_("Restoring package %1 ..."), package);
	    UI::ChangeWidget(`id(`progress), `Label, label);

	    string sel_type = lookup(info, "sel_type", "");

	    if (Mode::test == true)
	    {
		integer numf = (sel_type == "P") ? size(lookup(info, "sel_file", [])) : size(lookup(info, "files", []));

		while (numf > 0)
		{
		    restored = restored + 1;
		    UI::ChangeWidget(`id(`progress), `Value, restored);
		    sleep(300);
		    numf = numf - 1;
		}
	    }
	    else
	    {
		// get subarchive name
		string name = (package == "") ? "NOPACKAGE" : package + "-" + lookup(info, "vers", "");
		string fileinarchive = "";

		foreach(string f, arch_cont, ``{
			if (regexpmatch(f, "^" + name + "-........-.\\.tar.*") == true)
			{
			    y2milestone("package %1 is in archive file %2", package, f);
			    fileinarchive = f;
			}
		    }
		);

		if (fileinarchive == "")
		{
		    y2error("Can't find subarchive for package %1", package);
		}
		else
		{
		    // unpack subarchive
		    SCR::Execute(.target.bash, "export LC_ALL=C; /bin/tar -C " + targetdir + " -x -f " + Restore::GetArchiveName() + " " + fileinarchive);

		    // set compression parameter
		    string compress = "";
		    if (regexpmatch(fileinarchive, ".*\.tar\.gz$") == true)
		    {
			compress = "-z";
		    }
		    else if (regexpmatch(fileinarchive, ".*\.tar\.bz2$") == true)
		    {
			compress = "-j";
		    }

		    string RPMdb = (Restore::restoreRPMdb) ? "" : "--exclude var/lib/rpm";

		    // files to unpack, "" means all files
		    string unpackfiles = "";

		    // select files to unpack
		    if (sel_type == "P")
		    {
			// strip leading '/'
			foreach(string f, lookup(info, "sel_file", []), ``{
				if (size(f) > 1 && substring(f, 0, 1) == "/")
				{
				    unpackfiles = unpackfiles + " " + substring(f, 1);
				}
			    }
			);
		    }

		    // unpack files (or whole) subarchive
		    SCR::Execute(.target.bash, "export LC_ALL=C; /bin/tar -C " + "/tmp/restore" + " " + compress + " -x -f " + tmp + "/" + fileinarchive + " " + RPMdb + " " + unpackfiles);
		}
	    }
	}
    );

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();

	if (ret == `cancel)
	{
	    ret = `abort;
	}
    }
    while (ret != `next && ret != `abort && ret != `back);

    return ret;
}

global define symbol SWsingleDialog() ``{

/*    y2milestone("sw_single result: %1", CallModule("sw_single", ["beginner"]));
    CallModule("inst_suseconfig", []);*/

    term contents = `Label(_("Here will be sw_single dialog displayed and (un)installed packages."));

    Wizard::SetContents(_(""), contents, "", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();
    }
    while(ret != `next && ret != `abort && ret != `back);

    if (ret == `cancel)
    {
	ret = `abort;
    }

    return ret;

    //TODO after package (un)install refresh actual installed packages in Restore::

//    return `next;
}


global define symbol SuSEconfigDialog() ``{

    term contents = `Label(_("Here will be SuSEconfig started (optionally)."));

    Wizard::SetContents(_(""), contents, "", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();
    }
    while(ret != `next && ret != `abort && ret != `back);

    if (ret == `cancel)
    {
	ret = `abort;
    }

    return ret;
}


global define symbol SummaryDialog() ``{

    string basicinfo = "<P>Number of installed packages: 3<BR>Number of uninstalled packages: 0</P><P>Total restored packages: 34<BR>Total restored files: 228</P><P>Restore status: Ok</P>";
    string extendedinfo = "<P><BR><B>Details:</B></P><P>Lilo return status: Ok</P><P><B>Installed packages:</B><BR>dsfsd-2.5.2-2<BR>ssdgdsg-2.7.1-4<BR>qwqtrt-12.4.0-1</P><P><B>Restored files:</B><BR>/sdfsdf/sdf<BR>/sdf/sdf/sdf<BR></P>";

    return DisplaySummaryDialog(basicinfo, basicinfo + extendedinfo, "help", _("Summary of restoration"), `finish);
}



global define list CreateArchiveContentTable(map packagesinfo) ``{
    list ret = [];
    integer num = 0;

    if (packagesinfo != nil)
    {
	foreach(string p, map info, packagesinfo, ``{
		list files = lookup(info, "files", []);

		foreach(string file, files, ``{
			ret = add(ret, `item(`id(num), p, file));
			num = num + 1;
		    }
		);
	    }
	);
    }

    return ret;
}



global define list CreateTableContentsRestoreSelection(map backupselection, map installed) ``{
    list ret = [];
    // id of item in the table
    integer num = 0;

    if (backupselection != nil)
    {
	foreach(string p, map m, backupselection, ``{

		string ver = lookup(m, "vers", "");
		string descr = lookup(m, "descr", "");

		string seltype = lookup(m, "sel_type", " ");

		string numfiles = "";

		if (seltype == "X")
		{
		    numfiles = _("all");
		}
		else if (seltype == " ")
		{
		    numfiles = "";
		}
		else if (seltype == "P")
		{
		    integer total = size(lookup(m, "files", []));
		    integer sel = size(lookup(m, "sel_file", []));

		    numfiles = sformat(_("%1 of %2"), sel, total);
		}
		else
		{
		    y2error("Unknown selection type: %1", seltype);
		}

		// set name for "none" package
		if (p == "")
		{
		    p = _("<none>");
		}

		ret = add(ret, `item(`id(num), seltype, numfiles, p, ver, descr));

		num = num + 1;
	    }
	);
    }

    return ret;
}


}

