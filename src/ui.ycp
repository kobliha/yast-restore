/**
 * File:
 *   include/restore/ui.ycp
 *
 * Package:
 *   Restore module
 *
 * Summary:
 *   User interface functions.
 *
 * Authors:
 *   Ladislav Slezak <lslezak@suse.cz>
 *
 * $Id$
 *
 * All user interface functions.
 *
 */

{

textdomain "restore";

import "Wizard";
import "Wizard_hw";
import "Progress";
import "Restore";
import "Mode";

include "ui/common_popups.ycp";
include "ui/common_messages.ycp";
include "ui/file_popups.ycp";
include "wizard/sequencer.ycp";

include "restore/helps.ycp";
include "restore/summary_dialog.ycp";
include "restore/misc.ycp";
include "ui/common_messages.ycp";

global string restorepackagename = nil;

global list archivecontentscache = nil;

global list restoredfiles = [];
global list failedfiles = [];
global integer restoredpackages = 0;
global boolean lilostatus = nil;

// mounted directory
global string mountdir = "";

// entered archive name, can differ from local file name (e.g. nfs://server:dir/archive.tar)
global string input = "";

// list of found hosts on LAN
global list hosts = nil;

// map with detected removable devices
global map removabledevices = nil;

/**
 * Whole restoration
 * @return any Returned value from WizardSequencer() call
 */
global define any RestoreSequence () ``{
    map aliases =
	$[
	    "archive"	:   ``( ArchiveSelectionDialog(false) ),
	    "property"	:   ``( ArchivePropertyDialog() ),
	    "marchive"	: [ ``( ArchiveSelectionDialog(true) ), true ],
	    "contents"	: [ ``( ArchiveContentsDialog() ), true ],
	    "options"	: [ ``( RestoreOptionsDialog() ), true ],
	    "install"	:   ``( SelectionInstallDialog() ),
	    "uninstall"	:   ``( SelectionUninstallDialog() ),
	    "sw_single"	:   ``( SWsingleDialog() ),
	    "select"	:   ``( PackageSelectionRestoreDialog() ),
	    "selectfile": [ ``( FileSelectionDialog(restorepackagename) ), true ],
	    "restore"	: [ ``( RestoreProgressDialog() ), true ],
	    "SuSEconfig": [ ``( SuSEconfigDialog() ), true ],
	    "atexit"	:   ``( AtExit() ),
	    "summary"	:   ``( SummaryDialog() ),
	];

    map sequence = $[
	"ws_start" : "archive",
	"archive" :
	$[
	    `next	: "property",
	    `abort	: "atexit"
	],
	"marchive" :
	$[
	    `next	: "install",
	    `abort	: "atexit"
	],
	"property" :
	$[
	    `details	: "contents",
	    `options	: "options",
	    `multi	: "marchive",
	    `next	: "install",
	    `abort	: "atexit"
	],
	"contents" :
	$[
	    `next	: "property",
	    `abort	: "atexit"
	],
	"options" :
	$[
	    `next	: "property",
	    `abort	: "atexit"
	],
	"install" :
	$[
	    `next	: "uninstall",
	    `abort	: "atexit"
	],
	"uninstall" :
	$[
	    `next	: "sw_single",
	    `abort	: "atexit"
	],
	"sw_single" :
	$[
	    `next	: "select",
	    `abort	: "atexit"
	],
	"select" :
	$[
	    `files	: "selectfile",
	    `abort	: "atexit",
	    `next	: "restore"
	],
	"restore" :
	$[
	    `next	: "SuSEconfig",
	    `abort	: "atexit"
	],
	"SuSEconfig" :
	$[
	    `next	: "summary",
	    `abort	: "atexit"
	],
	"selectfile" :
	$[
	    `next	: "select",
	    `abort	: "atexit"
	],
	"summary" :
	$[
	    `abort	: "atexit",
	    `next	: "atexit"
	],
	"atexit" :
	$[
	    `next	: `next
	]
    ];

    string caption = _("Restore configuration");
    term contents = `Label (_("Initializing ..."));

    Wizard::CreateDialog ();
    Wizard::SetContentsButtons ( caption,
				contents,
				"",
				BackButtonLabel (),
				NextButtonLabel ());

    any ret = WizardSequencer (aliases, sequence);

    UI::CloseDialog ();
    return ret;
}

/**
 * Whole configuration of restore but without reading and writing.
 * For use with autoinstallation.
 * @return any Returned value from WizardSequencer() call
 */
global define any RestoreAutoSequence () ``{
    string caption = _("Restore configuration");
    term contents = `Label (_("Initializing ..."));

    Wizard::CreateDialog ();
    Wizard::SetContentsButtons ( caption,
				contents,
				"",
				BackButtonLabel (),
				NextButtonLabel ());

    // Run the main configuration workflow
    any ret = MainSequence ();

    UI::CloseDialog ();
    return ret;
}


/**
 * Backup archive is selected in this dialog.
 * @return symbol UI::UserInput() result
 */
global define symbol ArchiveSelectionDialog(boolean multivolume) ``{

    // cache removable devices
    if (removabledevices == nil)
    {
	removabledevices = DetectRemovable();
	y2milestone("Detected removable devices: %1", removabledevices);
    }

    if (multivolume == false)
    {
	// clear previous selection
	Restore::ResetArchiveSelection();
    }

    string file_name = "";
    string nfs_server = "";
    string nfs_file = "";
    string cd_file = "";

    symbol type = `file;
    string dev = "";

    // parse input - set previous selection
    if (input != "")
    {
	//parse variable 'input'
	string nfsprefix = "nfs://";
	string fileprefix = "file://";
	string cdprefix = "cd";
	string fdprefix = "fd";
	string devprefix = "dev://";

	if (substring(input, 0, size(nfsprefix)) == nfsprefix)
	{
	    string tail = substring(input, size(nfsprefix));
	    integer pos = findfirstof(tail, ":");

	    type = `nfs;
	    nfs_server = substring(tail, 0, pos);
	    nfs_file = substring(tail, pos + 1);

	    if (multivolume == true)
	    {
		string proposal = ProposeNextVolume(nfs_file);
		if (proposal != "")
		{
		    nfs_file = proposal;
		}
	    }
	}
	else if (substring(input, 0, size(fileprefix)) == fileprefix)
	{
	    type = `file;
	    file_name = substring(input, size(fileprefix));

	    if (multivolume == true)
	    {
		string proposal = ProposeNextVolume(file_name);
		if (proposal != "")
		{
		    file_name = proposal;
		}
	    }
	}
	else if (substring(input, 0, size(cdprefix)) == cdprefix || substring(input, 0, size(fdprefix)) == fdprefix || substring(input, 0, size(devprefix)) == devprefix)
	{
	    type = `removable;

	    if (substring(input, 0, size(cdprefix)) == cdprefix)
	    {
		string cdindex = regexpsub(input, "cd0*([0-9]*)://(.*)", "\\1");

		if (cdindex == nil || cdindex == "")
		{
		    cdindex = "0";
		}

		if (Mode::test == false)
		{
		    dev = lookup(select(SCR::Read(.probe.cdrom), tointeger(cdindex), ""), "dev_name", "");
		}

		cd_file = regexpsub(input, "cd0*([0-9]*)://(.*)", "\\2");

		if (cd_file == nil)
		{
		    cd_file = "";
		}
	    }
	    else if (substring(input, 0, size(fdprefix)) == fdprefix)
	    {
		string fdindex = regexpsub(input, "fd0*([0-9]*)://(.*)", "\\1");

		if (fdindex == nil || fdindex == "")
		{
		    fdindex = "0";
		}

		if (Mode::test == false)
		{
		    dev = lookup(select(SCR::Read(.probe.floppy), tointeger(fdindex), ""), "dev_name", "");
		}

		cd_file = regexpsub(input, "fd0*([0-9]*)://(.*)", "\\2");

		if (cd_file == nil)
		{
		    cd_file = "";
		}
	    }
	    else if (substring(input, 0, size(devprefix)) == devprefix)
	    {
		string tail = substring(input, size(devprefix));
		integer pos = findfirstof(tail, ":");

		dev = substring(tail, 0, pos);
		cd_file = substring(tail, pos + 1);
	    }

	    if (multivolume == true)
	    {
		string proposal = ProposeNextVolume(cd_file);
		if (proposal != "")
		{
		    cd_file = proposal;
		}
	    }
	}
	else
	{
	    y2error("Unknown prefix in input: %1", input);
	}
    }
    else
    {
	// set default values
	// TODO: remove this, use initialized values
	file_name = "/tmp/backup-new4/01_bk.tar";
	nfs_server = "dhcp28";
	nfs_file = "/local/backup.tar";
	cd_file = "/bk.tar";
    }

    // unmount previous file system
    Restore::Umount();

    term contents = `VBox(
		`Frame(_("Backup archive"),
			`HBox(
			    `RadioButtonGroup(`id(`source),
				`VBox(
				    `VSpacing(0.5),
				    `Left(`RadioButton(`id(`file), _("&Local file"), type == `file)),
				    `HBox(
					`HSpacing(2),
					`TextEntry(`id(`filename), _("Archive file na&me:"), file_name),
					`HSpacing(1),
					`Bottom(`PushButton(`id(`selectfile), _("&Select file...")))
				    ),
				    `VSpacing(1),
				    `Left(`RadioButton(`id(`nfs), _("N&FS"), type == `nfs)),
				    `HBox(
					`HSpacing(2),
					`TextEntry(`id(`nfsserver), _("I&P adress or name of NFS server:"), nfs_server),
					`HSpacing(1),
					`Bottom(`PushButton(`id(`selecthost), _("Select &host...")))
				    ),
				    `HBox(
					`HSpacing(2),
					`TextEntry(`id(`nfsfilename), _("&Archive file name:"), nfs_file)
				    ),
				    `VSpacing(1),
				    `Left(`RadioButton(`id(`removable), `opt(`notify), _("Rem&ovable device"), type == `removable)),
				    `HBox(
					`HSpacing(2),
					`Left(`ComboBox(`id(`device), `opt(`editable), _("&Device"), CreateDeviceList(removabledevices, dev)))
				    ),
				    `HBox(
					`HSpacing(2),
					`TextEntry(`id(`remfilename), _("Archi&ve file name:"), cd_file),
					`HSpacing(1),
					`Bottom(`PushButton(`id(`remfile), _("S&elect file")))
				    ),
				    `VSpacing(1)
				)
			    ),
			    `HSpacing(1)
			)
		    ),
		`VSpacing(1)
	);

    string help = (multivolume == false) ? _("Help") : _("Multivolume help");
    string title = (multivolume == false) ? _("Archive selection") : _("Multi volume archive selection");

    Wizard::SetContents(title, contents, help, true, true);


    symbol ret = nil;

    do
    {
	ret = UI::UserInput();

	if (ret == `selectfile)
	{
	    string file = PopupFile("/");

	    if (file != "")
	    {
		UI::ChangeWidget(`id(`filename), `Value, file);
	    }
	}
	if (ret == `selecthost)
	{
	    // cache found hosts
	    if (hosts == nil)
	    {
		hosts = (Mode::test == false) ? sort(SCR::Read(.net.hostnames)) :
		    // test mode data
		    [ "host1.local", "host2.local", "server1.local"];

		if (hosts == nil)
		{
		    hosts = [];
		}
	    }

	    string selectedhost = SelectFromList(_("Network &hosts:"), hosts, UI::QueryWidget(`id(`nfsserver), `Value));

	    if (selectedhost != "" && selectedhost != nil)
	    {
		UI::ChangeWidget(`id(`nfsserver), `Value, selectedhost);
	    }
	}
	else if (ret == `remfile)
	{
	    string selected = UI::QueryWidget(`id(`device), `Value);
	    string device = ComboToDevice(selected, removabledevices);
	    string fname = UI::QueryWidget(`id(`remfilename), `Value);

	    // file selection from removable device - mount device
	    map mount = Restore::MountInput(device + fname);

	    if (lookup(mount, "success", false) == true)
	    {
		string mountpnt = lookup(mount, "mpoint", "/");
		string file = PopupFile(mountpnt + "/");

		if (file != "")
		{
		    // check if file is under mountpoint directory
		    if (substring(file, 0, size(mountpnt)) != mountpnt)
		    {
			// selected file is out of mounted file system
			UI::ErrorPopup(_("Selected file is out of mounted filesystem"));
		    }
		    else
		    {
			// set file name
			UI::ChangeWidget(`id(`remfilename), `Value, substring(file, size(mountpnt)));
		    }
		}

		// umount file system
		SCR::Execute(.target.umount, mountpnt);
	    }
	    else
	    {
		UI::ErrorPopup(_("Can not mount file system"));
	    }
	}
	else if (ret == `next)
	{
	    symbol type = UI::QueryWidget(`id(`source), `CurrentButton);

	    if (Mode::test == true)
	    {
		input = "file:///tmp/testmodearchivename.tar";
	    }
	    else if (type == `file)
	    {
		input = "file://" + UI::QueryWidget(`id(`filename), `Value);
	    }
	    else if (type == `nfs)
	    {
		string server = UI::QueryWidget(`id(`nfsserver), `Value);
		string file = UI::QueryWidget(`id(`nfsfilename), `Value);

		input = "nfs://" + server + ":" + file;
	    }
	    else if (type == `removable)
	    {
		string selected = UI::QueryWidget(`id(`device), `Value);
		string device = ComboToDevice(selected, removabledevices);

		y2milestone("Selected removable device: %1", device);

		input = device + UI::QueryWidget(`id(`remfilename), `Value);
	    }
	    else
	    {
		y2error("Unknown source type %1", type);
	    }

	    boolean readresult = false;
	    boolean lastvolume = false;

	    // read archive file
	    UI::OpenDialog(`Label(_("Reading archive contents...")));

	    if (Restore::IsMultiVolume() == false)
	    {
		readresult = Restore::Read(input);
	    }
	    else
	    {
		// read next volume
		map nextresult = Restore::ReadNextVolume(input);
		readresult = lookup(nextresult, "success", false);
		lastvolume = lookup(nextresult, "lastvolume", false);
	    }

	    UI::CloseDialog();

	    if (readresult == false)
	    {
		UI::ErrorPopup(sformat(_("Can not read backup archive file '%1'!"), input));
		Restore::Umount();
		ret = `dummy;
	    }
	    else
	    {
		restoredfiles = [];
		failedfiles = [];

		if (Restore::IsMultiVolume() == true)
		{
		    // umount source and ask for next volume
		    Restore::Umount();

		    if (lastvolume == false)
		    {
			if (multivolume == true)
			{
			    symbol widget = nil;

			    if (type == `file)
			    {
				widget = `filename;
			    }
			    else if (type == `removable)
			    {
				widget = `remfilename;
			    }
			    else if (type == `nfs)
			    {
				widget = `nfsfilename;
			    }
			    else
			    {
				y2warning("Unknown source type: %1", type);
			    }

			    string fn = UI::QueryWidget(`id(widget), `Value);
			    string prop = ProposeNextVolume(fn);

			    if (prop != "")
			    {
				UI::ChangeWidget(`id(widget), `Value, prop);
			    }

			    ret = `dummy;
			}
		    }
		    else
		    {
			// last volume - test all volumes together
			boolean testall = Restore::TestAllVolumes();

			y2debug("TestAllVolumes(): %1", testall);

			if (testall == false)
			{
			    y2error("Test Restore::TestAllVolumes() failed");
			    UI::ErrorPopup(_("Volume test failed"));

			    ret = `back;
			}
		    }
		}
	    }
	}
	else if (ret == `cancel)
	{
	    ret = `abort;
	}
    }
    while (ret != `next && ret != `abort && ret != `back && ret != `multi);

    return ret;
}

/**
 * Display archive property - date of backup, user comment...
 * @return symbol UI::UserInput() result
 */
global define symbol ArchivePropertyDialog() ``{

    y2milestone("missing packages %1: ", Restore::GetMissingPackages());
    y2milestone("extra packages %1: ", Restore::GetExtraPackages());
    y2milestone("mismatched packages %1: ", Restore::GetMismatchedPackages());

    string date = Restore::GetArchiveDate();
    string hostname = Restore::GetArchiveHostname();
    string comment = Restore::GetArchiveComment();
    string archname = Restore::GetInputName();

    string multivolume = (Restore::IsMultiVolume() == true) ? _("Yes") : _("No");

    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`VSpacing(1),
		`Left(`HBox(`Label(`id(`flabel), _("Archive file name:")), `HSpacing(2), `Label(`id(`flabel2), archname))),
		`VSpacing(0.5),
		`Left(`HBox(`Label(`id(`dlabel), _("Date of backup:")), `HSpacing(2), `Label(`id(`dlabel2), date))),
		`VSpacing(0.5),
		`Left(`HBox(`Label(`id(`hlabel), _("Backup host name:")), `HSpacing(2), `Label(`id(`hlabel2), hostname))),
		`VSpacing(0.5),
		`Left(`HBox(`Label(`id(`mlabel), _("Multivolume archive:")), `HSpacing(2), `Label(`id(`mlabel2), multivolume))),
		`VSpacing(1.0),
		`MultiLineEdit(`id(`description), `opt(`disabled), _("Archive &description:"), comment),
		`VSpacing(1.0),
		`PushButton(`id(`details), _("&Show archive contents...")),
		`VSpacing(1),
		`PushButton(`id(`options), _("Res&tore options...")),
		`VSpacing(1.5)
	    ),
	    `HSpacing(2)
	);

    Wizard::SetContents(_("Archive properties"),
	contents, "help", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();

	if (ret == `cancel)
	{
	    ret = `abort;
	}
    }
    while (ret != `next && ret != `abort && ret != `back && ret != `details && ret != `options);

    if (Restore::IsMultiVolume() == true && Restore::TestAllVolumes() == false && ret == `next)
    {
	// ask for next volumes
	ret = `multi;
    }

    return ret;
}

/**
 * Create content for table widget - columns: selection mark, package name, version, description
 * @param contents Map $[ "packagename" : $[ "ver" : "version", "descr" : "short description" ] ]
 * @param defaultval if true "X" is in the first column, else " "
 * @return list Contents for Table widget
 */
global define list CreateTableContents(map contents, boolean defaultval) ``{
    list ret = [];
    integer num = 0;

    string defval = (defaultval == true) ? "X" : " ";

    if (contents != nil)
    {
	foreach(string p, map m, contents, ``{

		string ver = lookup(m, "ver", "");
		string descr = lookup(m, "descr", "");

		ret = add(ret, `item(`id(num), defval, p, ver, descr));
		num = num + 1;
	    }
	);
    }

    return ret;
}


/**
 * Create content for table widget - columns: selection mark, package name, backup version, installed version, description
 * @param contents Map $[ "packagename" : $[ "ver" : "version", "descr" : "short description" ] ]
 * @param defaultval if true "X" is in the first column, else " "
 * @return list Contents for Table widget
 */
global define list CreateTableContentsWithMismatched(map contents, boolean defaultval) ``{
    list ret = [];
    integer num = 0;

    string defval = (defaultval) ? "X" : " ";

    if (contents != nil)
    {
	foreach(string p, map m, contents, ``{

		string ver = lookup(m, "ver", "");
		string descr = lookup(m, "descr", "");
		string installed = lookup(m, "inst", "");

		ret = add(ret, `item(`id(num), defval, p, ver, installed, descr));
		num = num + 1;
	    }
	);
    }

    return ret;
}


/**
 * Dialog for package selection - packages to install
 * @return symbol UI::UserInput() result
 */
global define symbol SelectionInstallDialog() ``{

    // LATER: if all packages are installed return `next (or `back)

    map missingpackages = Restore::GetMissingPackages();

    // add mismatched packages
    foreach(string p, map info, Restore::GetMismatchedPackages(), ``{
	    missingpackages = add(missingpackages, p, info);
	}
    );

    list missing = CreateTableContentsWithMismatched(missingpackages, true);
    string widgetlabel = _("&Packages which will be installed");
    term header = `header(" ", _("Package"), _("Backup version"), _("Installed version"), _("Description"));

    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`VSpacing(1),
		`Table(`id(`pkg), `opt(`notify), header, missing),
		`VSpacing(1),
		`HBox(
		    `PushButton(`id(`all), _("&Select all")),
		    `PushButton(`id(`none), _("&Deselect all"))
		),
		`VSpacing(1.5)
	    ),
	    `HSpacing(2)
	);

    Wizard::SetContents(_("Package restoration - installation"), contents, "help", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();

	if (ret == `all)
	{
	    UI::ChangeWidget(`id(`pkg), `Items, CreateTableContentsWithMismatched(missingpackages, true));
	}
	else if (ret == `none)
	{
	    UI::ChangeWidget(`id(`pkg), `Items, CreateTableContentsWithMismatched(missingpackages, false));
	}
	else if (ret == `pkg)
	{
	    integer current = UI::QueryWidget(`id(`pkg), `CurrentItem);
	    string current_value = select(UI::QueryWidget(`id(`pkg), `Item(current)), 1, " ");

	    if (current_value == " ")
	    {
		current_value = "X";
	    }
	    else
	    {
		current_value = " ";
	    }

	    UI::ChangeWidget(`id(`pkg), `Item(current, 0), current_value);
	}
	else if (ret == `cancel)
	{
	    ret = `abort;
	}
    }
    while (ret != `next && ret != `abort && ret != `back);

    if (ret != `abort)
    {
	integer num = size(missingpackages);
	integer i = 0;
	map selected = $[];

	while (i < num)
	{
	    string s = select(UI::QueryWidget(`id(`pkg), `Item(i)), 1, " ");
	    string p = select(UI::QueryWidget(`id(`pkg), `Item(i)), 2, " ");

	    if (s == "X")
	    {
		map i = lookup(missingpackages, p, $[]);
		string v = lookup(i, "ver", "");
		selected = add(selected, p, $[ "ver" : v ]);
	    }

	    i = i + 1;
	}

	y2milestone("Selected packages to install: %1", selected);
    }

    // TODO: warn if some packages are not available on CDs and display path selection dialog to packages
    // LATER: allow to select package from backup archive (YOU stores packages to /var/... and they can be used)

    return ret;
}


/**
 * Dialog for package selection - packages to uninstall
 * @return symbol UI::UserInput() result
 */
global define symbol SelectionUninstallDialog() ``{

    // LATER: if all packages are installed return `next (or `back)

    map extrapackages = Restore::GetExtraPackages();
    list extra = CreateTableContents(extrapackages, true);

    string widgetlabel = _("&Packages which will be uninstalled");

    term header = `header(" ", _("Package"), _("Version"), _("Description"));

    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`VSpacing(1),
		`Table(`id(`pkg), `opt(`notify), header, extra),
		`VSpacing(1),
		`HBox(
		    `PushButton(`id(`all), _("&Select all")),
		    `PushButton(`id(`none), _("&Deselect all"))
		),
		`VSpacing(1.5)
	    ),
	    `HSpacing(2)
	);

    Wizard::SetContents(_("Package restoration - uninstallation"), contents, "help", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();

	if (ret == `all)
	{
	    UI::ChangeWidget(`id(`pkg), `Items, CreateTableContents(extrapackages, true));
	}
	else if (ret == `none)
	{
	    UI::ChangeWidget(`id(`pkg), `Items, CreateTableContents(extrapackages, false));
	}
	else if (ret == `pkg)
	{
	    integer current = UI::QueryWidget(`id(`pkg), `CurrentItem);
	    string current_value = select(UI::QueryWidget(`id(`pkg), `Item(current)), 1, " ");

	    if (current_value == " ")
	    {
		current_value = "X";
	    }
	    else
	    {
		current_value = " ";
	    }

	    UI::ChangeWidget(`id(`pkg), `Item(current, 0), current_value);
	}
	else if (ret == `cancel)
	{
	    ret = `abort;
	}
    }
    while (ret != `next && ret != `abort && ret != `back);

    if (ret != `abort)
    {
	integer num = size(extrapackages);
	integer i = 0;
	map selected = $[];

	while (i < num)
	{
	    string s = select(UI::QueryWidget(`id(`pkg), `Item(i)), 1, " ");
	    string p = select(UI::QueryWidget(`id(`pkg), `Item(i)), 2, " ");

	    if (s == "X")
	    {
		map i = lookup(extrapackages, p, $[]);
		string v = lookup(i, "ver", "");
		selected = add(selected, p, $[ "ver" : v ]);
	    }

	    i = i + 1;
	}

	y2milestone("Selected packages to uninstall: %1", selected);
    }

    return ret;
}

/**
 * Packages (and files) for restoration can be selected in this archive.
 * @return symbol UI::UserInput() result
 */
global define symbol PackageSelectionRestoreDialog() ``{

    // read product info
    boolean personal = false;  // TODO FIXME Product::personal;

    // in personal version is button = `Empty() and help text will be shorter
    term button = (!personal) ? `PushButton(`id(`files), _("S&elect files")) : `Empty();

    list tablecontents = CreateTableContentsRestoreSelection(Restore::GetArchiveInfo());
    integer position = 0;

    // refresh previous selection
    if (restorepackagename != nil)
    {
	foreach(term t, tablecontents, ``{
		if (restorepackagename == select(t, 3, ""))
		{
		    position = select(select(t, 0, `id(0)), 0, 0);
		}
	    }
	);
    }

    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`VSpacing(1),
		`Table(`id(`pkgtable),`opt(`notify), `header(" ", _("Files"), _("Package"), _("Version"), _("Description")), tablecontents),
		`VSpacing(0.2),
		`HBox(`PushButton(`id(`select), _("&Select all")), `PushButton(`id(`deselect), _("&Deselect all")), button),
		`VSpacing(1.5)
	    ),
	    `HSpacing(2)
	);

    string helptext = _("X = Restore all files from backup, P = Partiall restore of manually selected files");

    if (!personal)
    {
	helptext = helptext + _("<BR>To select files which will be restored from archive press <B>Select files</B> button.");
    }

    Wizard::SetContents(_("Packages to restore"), contents, helptext, true, true);

    // set currnet item in the table
    if (size(tablecontents) > 0)
    {
	UI::ChangeWidget(`id(`pkgtable), `CurrentItem, position);
    }


    symbol ret = nil;

    do
    {
	ret = UI::UserInput();

	integer current = 0;
	string current_value = "";
	string current_pkgname = "";

	if (size(tablecontents) > 0)
	{
	    current = UI::QueryWidget(`id(`pkgtable), `CurrentItem);
	    current_value = select(UI::QueryWidget(`id(`pkgtable), `Item(current)), 1, " ");
	    current_pkgname = select(UI::QueryWidget(`id(`pkgtable), `Item(current)), 3, "");
	}

	restorepackagename = current_pkgname;

	if (current_pkgname == _("<none>"))
	{
	    current_pkgname = "";
	}

	if (ret == `pkgtable)
	{
	    // toggle restore selection: "X" -> " ", " " -> "X", "P" -> " "
	    if (current_value == " ")
	    {
		// check if package is installed
		// TODO check versions
		if (current_pkgname != "" && haskey(Restore::GetActualInstalledPackages(), current_pkgname) == false)
		{
		    current_value = (UI::AnyQuestionPopup("", sformat(_("Package '%1' is not installed in your system.\nDo you really want to restore its files?"), current_pkgname), YesButtonLabel(), NoButtonLabel(), `focus_no) == true)  ? "X" : " " ;
		}
		else
		{
		    current_value = "X";
		}
	    }
	    else
	    {
		current_value = " ";
	    }

	    string selectionstring = (current_value == "X") ? _("all") : "";

	    UI::ChangeWidget(`id(`pkgtable), `Item(current, 0), current_value);
	    UI::ChangeWidget(`id(`pkgtable), `Item(current, 1), selectionstring);

	    Restore::SetRestoreSelection(current_pkgname, $["sel_type" : current_value]);
	}
	else if (ret == `files)
	{
	    // check if package is installed
	    // TODO check versions
	    if (current_value == " " && current_pkgname != "" && haskey(Restore::GetActualInstalledPackages(), current_pkgname) == false)
	    {
		if (UI::AnyQuestionPopup("", sformat(_("Package '%1' is not installed in your system.\nDo you really want to restore its files?"), current_pkgname), YesButtonLabel(), NoButtonLabel(), `focus_no) != true)
		{
		    ret = `dummy;
		}
	    }

	    restorepackagename = current_pkgname;
	}
	else if ((ret == `select || ret == `deselect) && size(tablecontents) > 0)
	{
	    // set selection type
	    string sel_type = (ret == `select) ? "X" : " ";

	    if (sel_type == "X")
	    {
		// check whether some packages are missing, ask if they should be selected too
		map missing = Restore::GetMissingPackages();
		boolean selmissing = false;

		if (missing != $[])
		{
		    string question = _("Some packages are not installed.\nDo you want to select them for restoration?");
		    selmissing = UI::AnyQuestionPopup("", question, YesButtonLabel(), NoButtonLabel(), `focus_no);
		}

		// ask about mismatched packages
		map mismatched = Restore::GetMismatchedPackages();
		boolean selmismatch = false;

		if (mismatched != $[])
		{
		    string question = _("Some installed packages have different\nversion than is in backup archive.\nDo you want to select them for restoration?");
		    selmismatch = UI::AnyQuestionPopup("", question, YesButtonLabel(), NoButtonLabel(), `focus_no);
		}

		// set selection type for packages
		foreach(string p, map info, Restore::GetArchiveInfo(), ``{
			string sel = sel_type;

			if (selmissing == false && haskey(missing, p) == true)
			{
			    sel = " ";
			}
			else if (selmismatch == false && haskey(mismatched, p) == true)
			{
			    sel = " ";
			}

			Restore::SetRestoreSelection(p, $["sel_type" : sel, "sel_file" : []]);
		    }
		);
	    }
	    else
	    {
		// set selection type for all packages
		foreach(string p, map info, Restore::GetArchiveInfo(), ``{
			Restore::SetRestoreSelection(p, $["sel_type" : sel_type, "sel_file" : []]);
		    }
		);
	    }

	    // change table contents
	    UI::ChangeWidget(`id(`pkgtable), `Items, CreateTableContentsRestoreSelection(Restore::GetArchiveInfo()));

	    // set previous selection
	    if (current != nil)
	    {
		UI::ChangeWidget(`id(`pkgtable), `CurrentItem, current);
	    }
	}
	else if (ret == `cancel)
	{
	    ret = `abort;
	}
    }
    while (ret != `next && ret != `abort && ret != `back && ret != `files);

    if (ret == `next)
    {
	map final = Restore::GetArchiveInfo();

	final = filter(string p, map i, final, ``{
		return (lookup(i, "sel_type", " ") != " ");
	    }
	);

	y2debug("Final restore selection: %1", final);
    }

    return ret;
}

/**
 * Dialog with options.
 * @return UI::UserInput() result
 */
global define symbol RestoreOptionsDialog() ``{
    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`VSpacing(1),
		`Left(`CheckBox(`id(`lilo), _("Run &lilo after restoration"), Restore::runlilo)),
		`VSpacing(0.2),
		`Left(`CheckBox(`id(`susecfg), _("Run &SuSEconfig after restoration"), Restore::runSuSEconfig)),
		`VSpacing(0.2),
		`Left(`CheckBox(`id(`rpmdb), _("Restore RPM &database (if present in archive)"), Restore::restoreRPMdb)),
		`VSpacing(1.5)
	    ),
	    `HSpacing(2)
	);

    Wizard::ReplaceNextButton(`PushButton(`id(`next), `opt(`default), OKButtonLabel()));

    Wizard::SetContents(_("Restore options"), contents, "help", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();
    }
    while(ret != `next && ret != `abort && ret != `back);

    if (ret == `cancel)
    {
	ret = `abort;
    }
    else
    {
	Restore::runlilo = UI::QueryWidget(`id(`lilo), `Value);
	Restore::runSuSEconfig = UI::QueryWidget(`id(`susecfg), `Value);
	Restore::restoreRPMdb = UI::QueryWidget(`id(`rpmdb), `Value);
    }

    Wizard::RestoreNextButton();

    return ret;
}

/**
 * Display all files in backup archive which belong to package. User can select wqhich files will be resored.
 * @return symbol UI::UserInput() result
 */
global define symbol FileSelectionDialog(string packagename) ``{

    // create multiselection widget contents

    map pkginfo = lookup(Restore::GetArchiveInfo(), packagename, $[]);

    string sel_type = lookup(pkginfo, "sel_type", " ");
    list files = lookup(pkginfo, "files", []);
    list sel_file = lookup(pkginfo, "sel_file", []);

    list cont = [];

    foreach(string f, files, ``{
	    boolean selected = false;

	    if (sel_type == "X")
	    {
		selected = true;
	    }
	    else if (sel_type == " ")
	    {
		selected = false;
	    }
	    else if (sel_type == "P")
	    {
		selected = contains(sel_file, f);
	    }
	    else
	    {
		y2error("Unknown selection type %1 in package %2", sel_type, packagename);
	    }

	    cont = add(cont, `item(`id(f), f, selected));
	}
    );

    string mlabel = _("&Files to restore");

    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`VSpacing(1),
		`ReplacePoint(`id(`rp), `MultiSelectionBox(`id(`mbox), mlabel, cont)),
		`VSpacing(1),
		`HBox(
		    `PushButton(`id(`all), _("&Select all")),
		    `PushButton(`id(`none), _("&Deselect all"))
		),
		`VSpacing(1.5)
	    ),
	    `HSpacing(2)
	);

    Wizard::ReplaceNextButton(`PushButton(`id(`next), `opt(`default), OKButtonLabel()));

    // for translatores: %1 is name of package (e.g. "aaa_base")
    Wizard::SetContents(sformat(_("File selection - package %1"), packagename), contents, "help", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();

	if (ret == `all || ret == `none)
	{
	    cont = [];
	    boolean selected = (ret == `all);

	    foreach(string f, files, ``{
		    cont = add(cont, `item(`id(f), f, selected));
		}
	    );

	    UI::ReplaceWidget(`id(`rp), `MultiSelectionBox(`id(`mbox), mlabel, cont));
	}
	else if (ret == `cancel)
	{
	    ret = `abort;
	}
    }
    while(ret != `next && ret != `abort && ret != `back);

    if (ret == `next)
    {
	string sel_type_new = "";
	// TODO save changes
	list sel = UI::QueryWidget(`id(`mbox), `SelectedItems);

	if (size(sel) == 0)
	{
	    sel_type_new = " ";
	}
	else if (size(sel) == size(files))
	{
	    sel_type_new = "X";
	    // clear list of selected files to save memory, "X" as sel_type is enough
	    sel = [];
	}
	else
	{
	    sel_type_new = "P";
	}

	Restore::SetRestoreSelection(packagename, $["sel_type" : sel_type_new, "sel_file" : sel]);
    }

    Wizard::RestoreNextButton();

    return ret;
}

/**
 * Display content of backup archive in the table.
 * @return symbol UI::UserInput() result
 */
global define symbol ArchiveContentsDialog() ``{

    Wizard::ClearContents();

    if (archivecontentscache == nil)
    {
	archivecontentscache = CreateArchiveContentTree(Restore::GetArchiveInfo());
    }

    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`VSpacing(1),
		`Tree(`id(`tree), _("Archive &content:"), CreateArchiveContentTree(Restore::GetArchiveInfo())),
		`VSpacing(1.5)
	    ),
	    `HSpacing(2)
	);

    Wizard::ReplaceNextButton(`PushButton(`id(`next), `opt(`default), OKButtonLabel()));

    Wizard::SetContents(_("Archive content"), contents, "help", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();

	if (ret == `cancel)
	{
	    ret = `abort;
	}
    }
    while (ret != `next && ret != `abort && ret != `back);

    Wizard::RestoreNextButton();

    return ret;
}

/**
 * Restore packages from backup archive - display progress of restoring process
 * @return symbol UI::UserInput() result
 */
global define symbol RestoreProgressDialog() ``{

    symbol ret = nil;
    symbol progressbar = `progress;

    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`VSpacing(1),
		`ProgressBar(`id(progressbar), " ", Restore::TotalPackagesToRestore(), 0),
		`VSpacing(1.5)
	    ),
	    `HSpacing(2)
	);

    // callback function for abort
    block callback = ``{
	include "ui/common_messages.ycp";

	symbol ret = UI::PollInput();
	boolean abort = false;

	if (ret == `abort || ret == `cancel)
	{
	    abort = UI::AnyQuestionPopup(_("Abort confirmation"), _("Do you really want to abort restore?"), YesButtonLabel(), NoButtonLabel(), `focus_no);
	}

	return abort;
    };

    Wizard::SetContents(_("Restoring files"), contents, "help", false, false);

    // start restoration
    map result = Restore::Write(callback, progressbar, "/tmp/restore");  // TODO FIXME: unpack to "/"

    // set values from restoration
    ret = (lookup(result, "aborted", false)) ? `abort : `next;

    if (ret == `next)
    {
	 restoredfiles = lookup(result, "restored", []);
	 failedfiles = lookup(result, "failed", []);
    }

    return ret;
}

/**
 * Start Yast2 package manager
 * @return symbol UI::UserInput() result
 */
global define symbol SWsingleDialog() ``{

    // TODO:  CallModule("sw_single", ["beginner"]);

    term contents = `Label(_("Here will be sw_single dialog displayed and (un)installed packages."));

    Wizard::SetContents("", contents, "", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();
    }
    while(ret != `next && ret != `abort && ret != `back);

    if (ret == `cancel)
    {
	ret = `abort;
    }

    return ret;

    //TODO after package (un)install refresh actual installed packages (do Restore::ReadActualInstalledPackages())
}

/**
 * Start SuSEconfig
 * @return symbol UI::UserInput() result
 */
global define symbol SuSEconfigDialog() ``{

    // TODO: CallModule("inst_suseconfig", []);

    term contents = `Label(_("Here will be SuSEconfig started (optionally)."));

    Wizard::SetContents("", contents, "", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();
    }
    while(ret != `next && ret != `abort && ret != `back);

    if (ret == `cancel)
    {
	ret = `abort;
    }

    return ret;
}

/**
 * Display summary of restoration
 * @return symbol UI::UserInput() result
 */
global define symbol SummaryDialog() ``{

    string basicinfo = "<P>Number of installed packages: 3<BR>Number of uninstalled packages: 0</P><P>Total restored packages: " + restoredpackages + "<BR>Total restored files: " + size(restoredfiles) + "</P><P>Restore status: Ok</P>";

    // display failed files if any
    if (size(failedfiles) > 0)
    {
	 basicinfo = basicinfo + "<P><B>Failed files</B><BR>" + mergestring(failedfiles, "<BR>") + "</P>";
    }

    // set lilo result string
    string lilostr = "<I>" + _("Not started") + "</I>";

    if (lilostatus == true)
    {
	lilostr = _("Ok");
    }
    else if (lilostatus == false)
    {
	lilostr = "<B>" + _("Failed") + "</B>";
    }


    string extendedinfo = "<P><BR><B>Details:</B></P><P>Lilo return status: " + lilostr + "</P><P><B>Installed packages:</B><BR>dsfsd-2.5.2-2<BR>ssdgdsg-2.7.1-4<BR>qwqtrt-12.4.0-1</P><P><B>Restored files:</B><BR>" + mergestring(restoredfiles, "<BR>") + "</P>";

    return DisplaySummaryDialog(basicinfo, basicinfo + extendedinfo, "help", _("Summary of restoration"), `finish);
}

/**
 * Return content for table widget - list of backup files
 * @param packagesinfo Map $[ "packagename" : $[ "files" : ["files in the archive"] ] ]
 * @return list Table content
 */
global define list CreateArchiveContentTable(map packagesinfo) ``{
    list ret = [];
    integer num = 0;

    if (packagesinfo != nil)
    {
	foreach(string p, map info, packagesinfo, ``{
		list files = lookup(info, "files", []);
		string version = lookup(info, "vers", "");

		foreach(string file, files, ``{
			ret = add(ret, `item(`id(num), p, version, file));
			num = num + 1;
		    }
		);
	    }
	);
    }

    return ret;
}

/**
 * Return content for table widget - list of backup files
 * @param packagesinfo Map $[ "packagename" : $[ "files" : ["files in the archive"] ] ]
 * @return list Table content
 */
global define list CreateArchiveContentTree(map packagesinfo) ``{
    list ret = [];
    integer num = 0;

    if (packagesinfo != nil)
    {
	foreach(string p, map info, packagesinfo, ``{
		list files = lookup(info, "files", []);
		string version = lookup(info, "vers", "");

		files = maplist(string s, files, ``{return `item(s);});

		if (p == "")
		{
		    p = _("-- No package --");
		}

		ret = add(ret, `item(`id(num), p + "-" + version, files));
		num = num + 1;
	    }
	);
    }

    return ret;
}

/**
 * Return table widget contens - files and packages selected for restoration
 * @param restoreselection Restore settings
 * @return list Table content
 */
global define list CreateTableContentsRestoreSelection(map restoreselection) ``{
    list ret = [];
    // id of item in the table
    integer num = 0;

    if (restoreselection != nil)
    {
	foreach(string p, map m, restoreselection, ``{

		string ver = lookup(m, "vers", "");
		string descr = lookup(m, "descr", "");

		string seltype = lookup(m, "sel_type", " ");

		string numfiles = "";

		if (seltype == "X")
		{
		    numfiles = _("all");
		}
		else if (seltype == " ")
		{
		    numfiles = "";
		}
		else if (seltype == "P")
		{
		    integer total = size(lookup(m, "files", []));
		    integer sel = size(lookup(m, "sel_file", []));

		    numfiles = sformat(_("%1 of %2"), sel, total);
		}
		else
		{
		    y2error("Unknown selection type: %1", seltype);
		}

		// set name for "none" package
		if (p == "")
		{
		    p = _("<none>");
		}

		ret = add(ret, `item(`id(num), seltype, numfiles, p, ver, descr));

		num = num + 1;
	    }
	);
    }

    return ret;
}

global define string SelectFromList(string label, list inputlist, string selected) ``{

    UI::OpenDialog(
	`HBox(
	    `VSpacing(10),
	    `VBox(
		`HSpacing(40),
		`SelectionBox(`id(`selbox), label, inputlist),
		`HBox(
		    `PushButton(`id(`ok), `opt(`default), OKButtonLabel()),
		    `PushButton(`id(`cancel), CancelButtonLabel())
		)
	    )
	)
    );

    if (contains(inputlist, selected))
    {
	UI::ChangeWidget(`id(`selbox), `CurrentItem, selected);
    }

    UI::SetFocus(`id(`ok));

    symbol uinput = nil;

    do
    {
	uinput = UI::UserInput();
    }
    while (uinput != `ok && uinput != `cancel);

    string ret = (uinput == `cancel) ? "" : UI::QueryWidget(`id(`selbox), `CurrentItem);

    UI::CloseDialog();

    return ret;
}


global define map DetectRemovable() ``{
    map ret = $[];

    // detect floppy devices
    list devices = (Mode::test == false) ? SCR::Read(.probe.floppy) : [$["bus":"Floppy", "class_id":262, "dev_name":"/dev/fd0", "notready":true, "old_unique_key":"xjDN.oZ89vuho4Y3", "resource":$["size":[$["unit":"cinch", "x":350, "y":0], $["unit":"sectors", "x":2880, "y":512]]], "sub_class_id":3, "unique_key":"sPPV.oZ89vuho4Y3"]];
    integer num = 0;

    foreach(map dev, devices, ``{
	    string dev_name = lookup(dev, "dev_name", "");
	    string device = lookup(dev, "device", "");

	    if (device == "")
	    {
		if (lookup(dev, "bus", "") == "Floppy")
		{
		    device = _("Floppy");
		}
	    }

	    if (dev_name != "")
	    {
		ret = add(ret, dev_name, $[ "device" : device, "type" : "fd" + num + "://" ]);
	    }

	    num = num + 1;
	}
    );

    // detect cdrom devices
    devices = (Mode::test == false) ? SCR::Read(.probe.cdrom) : [$["bus":"IDE", "cdtype":"cdrom", "class_id":262, "dev_name":"/dev/hdc", "device":"CD-540E", "driver":"ide-cdrom", "notready":true, "old_unique_key":"3JYE.3LYJ0fijWD1", "resource":$["size":[$["unit":"sectors", "x":0, "y":512]]], "rev":"1.0A", "sub_class_id":2, "unique_key":"hY5p.ZxKxy3YdB66"]];
    num = 0;

    foreach(map dev, devices, ``{
	    string dev_name = lookup(dev, "dev_name", "");
	    string device = lookup(dev, "device", "");

	    if (dev_name != "")
	    {
		ret = add(ret, dev_name, $[ "device" : device, "type" : "cd" + num + "://" ]);
	    }

	    num = num + 1;
	}
    );

    return ret;
}


global define list CreateDeviceList(map dev, string sel) ``{
    list ret = [];

    // add selected device list if it's missing in map
    if (sel != nil && sel != "" && !haskey(dev, sel))
    {
	ret = [ `item(`id(sel), sel) ];
    }

    foreach(string d, map info, dev, ``{
	    ret = add(ret, `item(`id(lookup(info, "device", "") + " (" + d + ")"), lookup(info, "device", "") + " (" + d + ")", sel == d));
	}
    );

    return ret;
}


global define string ComboToDevice(string selected, map dev) ``{
    string ret = "";

    foreach(string d, map info, dev, ``{
	    if (selected == lookup(info, "device", "") + " (" + d + ")")
	    {
		ret = lookup(info, "type", "cd://");
	    }
	}
    );

    if (ret == "")
    {
	ret = "dev://" + selected + ":";
    }

    return ret;
}


global define string ProposeNextVolume(string volume) ``{
    // increase number in file name
    integer pos = findlastof(volume, "/");
    string volumedir = (pos != nil) ? substring(volume, 0, pos + 1) : "";
    string volumefile = (pos != nil) ? substring(volume, pos + 1) : volume;

    // ignore leading zeroes, 0xxx means octal number in tointeger() builtin
    integer volumenum = tointeger(regexpsub(volumefile, "0*([0-9]+)([^0-9]*)", "\\1"));

    string volumebase = regexpsub(volumefile, "([0-9]+)([^0-9]*)", "\\2");
    string newvolume = "";

    if (volumenum != nil)
    {
	volumenum = volumenum + 1;
	newvolume = sformat("%1", volumenum);

	if (size(newvolume) == 1)
	{
	    newvolume = "0" + newvolume;
	}

	return volumedir + newvolume + volumebase;
    }
    else
    {
	return "";
    }
}
/**
 * This function should be called only once before end of client. This function
 * cleans up the system - unmounts mounted files systems.
 * @return symbol Returns symbol `next for wizard sequencer
 */

global define symbol AtExit() ``{

    // unmount file system
    Restore::Umount();

    return `next;
}

}

