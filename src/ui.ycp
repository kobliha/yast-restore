/**
 * File:
 *   include/restore/ui.ycp
 *
 * Package:
 *   Restore module
 *
 * Summary:
 *   User interface functions.
 *
 * Authors:
 *   Ladislav Slezak <lslezak@suse.cz>
 *
 * $Id$
 *
 * All user interface functions.
 *
 */

{

textdomain "restore";

import "Wizard";
import "Wizard_hw";
import "Progress";
import "Restore";
import "Mode";

include "ui/common_popups.ycp";
include "ui/common_messages.ycp";
include "ui/file_popups.ycp";
include "wizard/sequencer.ycp";

include "restore/helps.ycp";
include "restore/summary_dialog.ycp";
include "restore/misc.ycp";
include "ui/common_messages.ycp";

global string restorepackagename = nil;

global list archivecontentscache = nil;

global list restoredfiles = [];
global list failedfiles = [];
global integer restoredpackages = 0;
global boolean lilostatus = nil;

// mounted directory
global string mountdir = "";

// entered archive name, can differ from local file name (e.g. nfs://server:dir/archive.tar)
global string input = "";


/**
 * Whole restoration
 * @return any Returned value from WizardSequencer() call
 */
global define any RestoreSequence () ``{
    map aliases =
	$[
	    "archive"	:   ``( ArchiveSelectionDialog() ),
	    "property"	:   ``( ArchivePropertyDialog() ),
	    "contents"	: [ ``( ArchiveContentsDialog() ), true ],
	    "options"	: [ ``( RestoreOptionsDialog() ), true ],
	    "install"	:   ``( SelectionInstallDialog() ),
	    "uninstall"	:   ``( SelectionUninstallDialog() ),
	    "sw_single"	:   ``( SWsingleDialog() ),
	    "select"	:   ``( PackageSelectionRestoreDialog() ),
	    "selectfile": [ ``( FileSelectionDialog(restorepackagename) ), true ],
	    "restore"	: [ ``( RestoreProgressDialog() ), true ],
	    "SuSEconfig": [ ``( SuSEconfigDialog() ), true ],
	    "atexit"	:   ``( AtExit() ),
	    "summary"	:   ``( SummaryDialog() ),
	];

    map sequence = $[
	"ws_start" : "archive",
	"archive" :
	$[
	    `options	: "options",
	    `next	: "property",
	    `abort	: "atexit"
	],
	"property" :
	$[
	    `details	: "contents",
	    `next	: "install",
	    `abort	: "atexit"
	],
	"contents" :
	$[
	    `next	: "property",
	    `abort	: "atexit"
	],
	"options" :
	$[
	    `next	: "archive",
	    `abort	: "atexit"
	],
	"install" :
	$[
	    `next	: "uninstall",
	    `abort	: "atexit"
	],
	"uninstall" :
	$[
	    `next	: "sw_single",
	    `abort	: "atexit"
	],
	"sw_single" :
	$[
	    `next	: "select",
	    `abort	: "atexit"
	],
	"select" :
	$[
	    `files	: "selectfile",
	    `abort	: "atexit",
	    `next	: "restore"
	],
	"restore" :
	$[
	    `next	: "SuSEconfig",
	    `abort	: "atexit"
	],
	"SuSEconfig" :
	$[
	    `next	: "summary",
	    `abort	: "atexit"
	],
	"selectfile" :
	$[
	    `next	: "select",
	    `abort	: "atexit"
	],
	"summary" :
	$[
	    `abort	: "atexit",
	    `next	: "atexit"
	],
	"atexit" :
	$[
	    `next	: `next
	]
    ];

    string caption = _("Restore configuration");
    term contents = `Label (_("Initializing ..."));

    Wizard::CreateDialog ();
    Wizard::SetContentsButtons ( caption,
				contents,
				"",
				BackButtonLabel (),
				NextButtonLabel ());

    any ret = WizardSequencer (aliases, sequence);

    UI::CloseDialog ();
    return ret;
}

/**
 * Whole configuration of restore but without reading and writing.
 * For use with autoinstallation.
 * @return any Returned value from WizardSequencer() call
 */
global define any RestoreAutoSequence () ``{
    string caption = _("Restore configuration");
    term contents = `Label (_("Initializing ..."));

    Wizard::CreateDialog ();
    Wizard::SetContentsButtons ( caption,
				contents,
				"",
				BackButtonLabel (),
				NextButtonLabel ());

    // Run the main configuration workflow
    any ret = MainSequence ();

    UI::CloseDialog ();
    return ret;
}


/**
 * Backup archive is selected in this dialog.
 * @return symbol UI::UserInput() result
 */
global define symbol ArchiveSelectionDialog() ``{

    string file_name = "";
    string nfs_server = "";
    string nfs_file = "";
    string cd_file = "";

    symbol type = `file;

    // parse input - set previous selection
    if (input != "")
    {
	//parse variable 'input'
	string nfsprefix = "nfs://";
	string fileprefix = "file://";
	string cdprefix = "cd://";

	if (substring(input, 0, size(nfsprefix)) == nfsprefix)
	{
	    string tail = substring(input, size(nfsprefix));
	    integer pos = findfirstof(tail, ":");

	    type = `nfs;
	    nfs_server = substring(tail, 0, pos);
	    nfs_file = substring(tail, pos + 1);
	}
	else if (substring(input, 0, size(fileprefix)) == fileprefix)
	{
	    type = `file;
	    file_name = substring(input, size(fileprefix));
	}
	else if (substring(input, 0, size(cdprefix)) == cdprefix)
	{
	    type = `cd;
	}
	else
	{
	    y2error("Unknown prefix in input: %1", input);
	}
    }
    else
    {
	// set default values
	file_name = "/tmp/bk.tar";
	nfs_server = "dhcp28";
	nfs_file = "/local/bk.tar";
	cd_file = "";
    }

    term contents = `VBox(
		`Frame("Backup archive",
			`RadioButtonGroup(`id(`source),
			    `VBox(
				`VSpacing(0.5),
				`Left(`RadioButton(`id(`file), _("L&ocal file"), type == `file)),
				`HBox(
				    `HSpacing(2),
				    `TextEntry(`id(`filename), _("Archive file na&me:"), file_name),
				    `HSpacing(2),
				    `PushButton(`id(`selectfile), _("&Select file"))
				),
				`VSpacing(1.5),
				`Left(`RadioButton(`id(`nfs), _("N&FS"), type == `nfs)),
				`HBox(
				    `HSpacing(2),
				    `TextEntry(`id(`nfsserver), _("I&P adress or name of NFS server:"), nfs_server),
				    `HSpacing(2)
				),
				`HBox(
				    `HSpacing(2),
				    `TextEntry(`id(`nfsfilename), _("&Archive file name:"), nfs_file),
				    `HSpacing(2)
				),
				`VSpacing(1.5),
				`Left(`RadioButton(`id(`cd), _("&CD disk"), type == `cd)),
				`HBox(
				    `HSpacing(2),
				    `TextEntry(`id(`cdfilename), _("Arc&hive file name:"), cd_file),
				    `HSpacing(2),
				    `PushButton(`id(`cdfile), _("S&elect file"))
				),
				`VSpacing(1)
			    )
			)
		    ),
		`VSpacing(1),
		`PushButton(`id(`options), _("Res&tore options...")),
		`VSpacing(1)
	);

    Wizard::SetContents(_("Archive selection"),
	contents, "help", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();

	if (ret == `selectfile)
	{
	    string file = PopupFile("/");
	    UI::ChangeWidget(`id(`filename), `Value, file);
	}
	else if (ret == `next)
	{
	    symbol type = UI::QueryWidget(`id(`source), `CurrentButton);

	    if (Mode::test == true)
	    {
		input = "file:///tmp/testmodearchivename.tar";
	    }
	    else if (type == `file)
	    {
		input = "file://" + UI::QueryWidget(`id(`filename), `Value);
	    }
	    else if (type == `nfs)
	    {
		string server = UI::QueryWidget(`id(`nfsserver), `Value);
		string file = UI::QueryWidget(`id(`nfsfilename), `Value);

		input = "nfs://" + server + ":" + file;
	    }
	    else if (type == `cd)
	    {
		input = "cd://" + UI::QueryWidget(`id(`cdfilename), `Value);
	    }
	    else
	    {
		y2error("Unknown source type %1", type);
	    }


		// read archive file
		UI::OpenDialog(`Label(_("Reading archive contents...")));
		boolean readresult = Restore::Read(input);
		UI::CloseDialog();

		if (readresult == false)
		{
		    UI::ErrorPopup(sformat(_("Can not read backup archive file '%1'!"), input));
		    ret = `dummy;
		}
		else
		{
		    restoredfiles = [];
		    failedfiles = [];
		}
	}
	else if (ret == `cancel)
	{
	    ret = `abort;
	}
    }
    while (ret != `next && ret != `abort && ret != `back && ret != `options);

    return ret;
}

/**
 * Display archive property - date of backup, user comment...
 * @return symbol UI::UserInput() result
 */
global define symbol ArchivePropertyDialog() ``{

    y2milestone("missing packages %1: ", Restore::GetMissingPackages());
    y2milestone("extra packages %1: ", Restore::GetExtraPackages());
    y2milestone("mismatched packages %1: ", Restore::GetMismatchedPackages());

    string date = Restore::GetArchiveDate();
    string hostname = Restore::GetArchiveHostname();
    string comment = Restore::GetArchiveComment();
    string archname = Restore::GetInputName();

    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`VSpacing(1),
		`Left(`HBox(`Label(`id(`flabel), _("Archive file name:")), `HSpacing(2), `Label(`id(`flabel2), archname))),
		`VSpacing(0.5),
		`Left(`HBox(`Label(`id(`dlabel), _("Date of backup:")), `HSpacing(2), `Label(`id(`dlabel2), date))),
		`VSpacing(0.5),
		`Left(`HBox(`Label(`id(`hlabel), _("Backup host name:")), `HSpacing(2), `Label(`id(`hlabel2), hostname))),
		`VSpacing(1.0),
		`MultiLineEdit(`id(`description), `opt(`disabled), _("Archive &description:"), comment),
		`VSpacing(1.0),
		`PushButton(`id(`details), _("&Show archive contents...")),
		`VSpacing(2)
	    ),
	    `HSpacing(2)
	);

    Wizard::SetContents(_("Archive properties"),
	contents, "help", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();

    }
    while(ret != `next && ret != `abort && ret != `back && ret != `details);

    if (ret == `cancel)
    {
	ret = `abort;
    }

    return ret;
}

/**
 * Create content for table widget - columns: selection mark, package name, version, description
 * @param contents Map $[ "packagename" : $[ "ver" : "version", "descr" : "short description" ] ]
 * @param defaultval if true "X" is in the first column, else " "
 * @return list Contents for Table widget
 */
global define list CreateTableContents(map contents, boolean defaultval) ``{
    list ret = [];
    integer num = 0;

    string defval = (defaultval == true) ? "X" : " ";

    if (contents != nil)
    {
	foreach(string p, map m, contents, ``{

		string ver = lookup(m, "ver", "");
		string descr = lookup(m, "descr", "");

		ret = add(ret, `item(`id(num), defval, p, ver, descr));
		num = num + 1;
	    }
	);
    }

    return ret;
}


/**
 * Create content for table widget - columns: selection mark, package name, backup version, installed version, description
 * @param contents Map $[ "packagename" : $[ "ver" : "version", "descr" : "short description" ] ]
 * @param defaultval if true "X" is in the first column, else " "
 * @return list Contents for Table widget
 */
global define list CreateTableContentsWithMismatched(map contents, boolean defaultval) ``{
    list ret = [];
    integer num = 0;

    string defval = (defaultval) ? "X" : " ";

    if (contents != nil)
    {
	foreach(string p, map m, contents, ``{

		string ver = lookup(m, "ver", "");
		string descr = lookup(m, "descr", "");
		string installed = lookup(m, "inst", "");

		ret = add(ret, `item(`id(num), defval, p, ver, installed, descr));
		num = num + 1;
	    }
	);
    }

    return ret;
}


/**
 * Dialog for package selection - packages to install
 * @return symbol UI::UserInput() result
 */
global define symbol SelectionInstallDialog() ``{

    // LATER: if all packages are installed return `next (or `back)

    map missingpackages = Restore::GetMissingPackages();

    // add mismatched packages
    foreach(string p, map info, Restore::GetMismatchedPackages(), ``{
	    missingpackages = add(missingpackages, p, info);
	}
    );

    list missing = CreateTableContentsWithMismatched(missingpackages, true);
    string widgetlabel = _("&Packages which will be installed");
    term header = `header(" ", _("Package"), _("Backup version"), _("Installed version"), _("Description"));

    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`VSpacing(1),
		`Table(`id(`pkg), `opt(`notify), header, missing),
		`VSpacing(1),
		`HBox(
		    `PushButton(`id(`all), _("&Select all")),
		    `PushButton(`id(`none), _("&Deselect all"))
		),
		`VSpacing(1.5)
	    ),
	    `HSpacing(2)
	);

    Wizard::SetContents(_("Package restoration - installation"), contents, "help", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();

	if (ret == `all)
	{
	    UI::ChangeWidget(`id(`pkg), `Items, CreateTableContentsWithMismatched(missingpackages, true));
	}
	else if (ret == `none)
	{
	    UI::ChangeWidget(`id(`pkg), `Items, CreateTableContentsWithMismatched(missingpackages, false));
	}
	else if (ret == `pkg)
	{
	    integer current = UI::QueryWidget(`id(`pkg), `CurrentItem);
	    string current_value = select(UI::QueryWidget(`id(`pkg), `Item(current)), 1, " ");

	    if (current_value == " ")
	    {
		current_value = "X";
	    }
	    else
	    {
		current_value = " ";
	    }

	    UI::ChangeWidget(`id(`pkg), `Item(current, 0), current_value);
	}
	else if (ret == `cancel)
	{
	    ret = `abort;
	}
    }
    while (ret != `next && ret != `abort && ret != `back);

    if (ret != `abort)
    {
	integer num = size(missingpackages);
	integer i = 0;
	map selected = $[];

	while (i < num)
	{
	    string s = select(UI::QueryWidget(`id(`pkg), `Item(i)), 1, " ");
	    string p = select(UI::QueryWidget(`id(`pkg), `Item(i)), 2, " ");

	    if (s == "X")
	    {
		map i = lookup(missingpackages, p, $[]);
		string v = lookup(i, "ver", "");
		selected = add(selected, p, $[ "ver" : v ]);
	    }

	    i = i + 1;
	}

	y2milestone("Selected packages to install: %1", selected);
    }

    // TODO: warn if some packages are not available on CDs and display path selection dialog to packages
    // LATER: allow to select package from backup archive (YOU stores packages to /var/... and they can be used)

    return ret;
}


/**
 * Dialog for package selection - packages to uninstall
 * @return symbol UI::UserInput() result
 */
global define symbol SelectionUninstallDialog() ``{

    // LATER: if all packages are installed return `next (or `back)

    map extrapackages = Restore::GetExtraPackages();
    list extra = CreateTableContents(extrapackages, true);

    string widgetlabel = _("&Packages which will be uninstalled");

    term header = `header(" ", _("Package"), _("Version"), _("Description"));

    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`VSpacing(1),
		`Table(`id(`pkg), `opt(`notify), header, extra),
		`VSpacing(1),
		`HBox(
		    `PushButton(`id(`all), _("&Select all")),
		    `PushButton(`id(`none), _("&Deselect all"))
		),
		`VSpacing(1.5)
	    ),
	    `HSpacing(2)
	);

    Wizard::SetContents(_("Package restoration - uninstallation"), contents, "help", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();

	if (ret == `all)
	{
	    UI::ChangeWidget(`id(`pkg), `Items, CreateTableContents(extrapackages, true));
	}
	else if (ret == `none)
	{
	    UI::ChangeWidget(`id(`pkg), `Items, CreateTableContents(extrapackages, false));
	}
	else if (ret == `pkg)
	{
	    integer current = UI::QueryWidget(`id(`pkg), `CurrentItem);
	    string current_value = select(UI::QueryWidget(`id(`pkg), `Item(current)), 1, " ");

	    if (current_value == " ")
	    {
		current_value = "X";
	    }
	    else
	    {
		current_value = " ";
	    }

	    UI::ChangeWidget(`id(`pkg), `Item(current, 0), current_value);
	}
	else if (ret == `cancel)
	{
	    ret = `abort;
	}
    }
    while (ret != `next && ret != `abort && ret != `back);

    if (ret != `abort)
    {
	integer num = size(extrapackages);
	integer i = 0;
	map selected = $[];

	while (i < num)
	{
	    string s = select(UI::QueryWidget(`id(`pkg), `Item(i)), 1, " ");
	    string p = select(UI::QueryWidget(`id(`pkg), `Item(i)), 2, " ");

	    if (s == "X")
	    {
		map i = lookup(extrapackages, p, $[]);
		string v = lookup(i, "ver", "");
		selected = add(selected, p, $[ "ver" : v ]);
	    }

	    i = i + 1;
	}

	y2milestone("Selected packages to uninstall: %1", selected);
    }

    return ret;
}

/**
 * Packages (and files) for restoration can be selected in this archive.
 * @return symbol UI::UserInput() result
 */
global define symbol PackageSelectionRestoreDialog() ``{

    // TODO: read this value from system
    boolean profi = true;

    // in personal version is button = `Empty() and help text will be shorter
    term button = (profi) ? `PushButton(`id(`files), _("S&elect files")) : `Empty();

    string help_profi = "To select files which will be restored from archive press <B>Select files</B> button.";

    list tablecontents = CreateTableContentsRestoreSelection(Restore::GetArchiveInfo());
    integer position = 0;

    // refresh previous selection
    if (restorepackagename != nil)
    {
	foreach(term t, tablecontents, ``{
		if (restorepackagename == select(t, 3, ""))
		{
		    position = select(select(t, 0, `id(0)), 0, 0);
		}
	    }
	);
    }

    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`VSpacing(1),
		`Table(`id(`pkgtable),`opt(`notify), `header(" ", _("Files"), _("Package"), _("Version"), _("Description")), tablecontents),
		`VSpacing(0.2),
		`HBox(`PushButton(`id(`select), _("&Select all")), `PushButton(`id(`deselect), _("&Deselect all")), button),
		`VSpacing(1.5)
	    ),
	    `HSpacing(2)
	);

    Wizard::SetContents(_("Packages to restore"),
	contents, "X = Restore all files from backup, P = Partiall restore of manually selected files", true, true);

    // set currnet item in the table
    if (size(tablecontents) > 0)
    {
	UI::ChangeWidget(`id(`pkgtable), `CurrentItem, position);
    }


    symbol ret = nil;

    do
    {
	ret = UI::UserInput();

	integer current = 0;
	string current_value = "";
	string current_pkgname = "";

	if (size(tablecontents) > 0)
	{
	    current = UI::QueryWidget(`id(`pkgtable), `CurrentItem);
	    current_value = select(UI::QueryWidget(`id(`pkgtable), `Item(current)), 1, " ");
	    current_pkgname = select(UI::QueryWidget(`id(`pkgtable), `Item(current)), 3, "");
	}

	restorepackagename = current_pkgname;

	if (current_pkgname == _("<none>"))
	{
	    current_pkgname = "";
	}

	if (ret == `pkgtable)
	{
	    // toggle restore selection: "X" -> " ", " " -> "X", "P" -> " "
	    if (current_value == " ")
	    {
		// check if package is installed
		// TODO check versions
		if (current_pkgname != "" && haskey(Restore::GetActualInstalledPackages(), current_pkgname) == false)
		{
		    current_value = (UI::AnyQuestionPopup("", sformat(_("Package '%1' is not installed in your system.\nDo you really want to restore its files?"), current_pkgname), YesButtonLabel(), NoButtonLabel(), `focus_no) == true)  ? "X" : " " ;
		}
		else
		{
		    current_value = "X";
		}
	    }
	    else
	    {
		current_value = " ";
	    }

	    string selectionstring = (current_value == "X") ? _("all") : "";

	    UI::ChangeWidget(`id(`pkgtable), `Item(current, 0), current_value);
	    UI::ChangeWidget(`id(`pkgtable), `Item(current, 1), selectionstring);

	    Restore::SetRestoreSelection(current_pkgname, $["sel_type" : current_value]);
	}
	else if (ret == `files)
	{
	    // check if package is installed
	    // TODO check versions
	    if (current_value == " " && current_pkgname != "" && haskey(Restore::GetActualInstalledPackages(), current_pkgname) == false)
	    {
		if (UI::AnyQuestionPopup("", sformat(_("Package '%1' is not installed in your system.\nDo you really want to restore its files?"), current_pkgname), YesButtonLabel(), NoButtonLabel(), `focus_no) != true)
		{
		    ret = `dummy;
		}
	    }

	    restorepackagename = current_pkgname;
	}
	else if ((ret == `select || ret == `deselect) && size(tablecontents) > 0)
	{
	    // set selection type
	    string sel_type = (ret == `select) ? "X" : " ";

	    if (sel_type == "X")
	    {
		// check whether some packages are missing, ask if they should be selected too
		map missing = Restore::GetMissingPackages();
		boolean selmissing = false;

		if (missing != $[])
		{
		    string question = _("Some packages are not installed.\nDo you want to select them for restoration?");
		    selmissing = UI::AnyQuestionPopup("", question, YesButtonLabel(), NoButtonLabel(), `focus_no);
		}

		// ask about mismatched packages
		map mismatched = Restore::GetMismatchedPackages();
		boolean selmismatch = false;

		if (mismatched != $[])
		{
		    string question = _("Some installed packages have different\nversion than is in backup archive.\nDo you want to select them for restoration?");
		    selmismatch = UI::AnyQuestionPopup("", question, YesButtonLabel(), NoButtonLabel(), `focus_no);
		}

		// set selection type for packages
		foreach(string p, map info, Restore::GetArchiveInfo(), ``{
			string sel = sel_type;

			if (selmissing == false && haskey(missing, p) == true)
			{
			    sel = " ";
			}
			else if (selmismatch == false && haskey(mismatched, p) == true)
			{
			    sel = " ";
			}

			Restore::SetRestoreSelection(p, $["sel_type" : sel, "sel_file" : []]);
		    }
		);
	    }
	    else
	    {
		// set selection type for all packages
		foreach(string p, map info, Restore::GetArchiveInfo(), ``{
			Restore::SetRestoreSelection(p, $["sel_type" : sel_type, "sel_file" : []]);
		    }
		);
	    }

	    // change table contents
	    UI::ChangeWidget(`id(`pkgtable), `Items, CreateTableContentsRestoreSelection(Restore::GetArchiveInfo()));

	    // set previous selection
	    if (current != nil)
	    {
		UI::ChangeWidget(`id(`pkgtable), `CurrentItem, current);
	    }
	}
	else if (ret == `cancel)
	{
	    ret = `abort;
	}
    }
    while (ret != `next && ret != `abort && ret != `back && ret != `files);

    if (ret == `next)
    {
	map final = Restore::GetArchiveInfo();

	final = filter(string p, map i, final, ``{
		return (lookup(i, "sel_type", " ") != " ");
	    }
	);

	y2debug("Final restore selection: %1", final);
    }

    return ret;
}

/**
 * Dialog with options.
 * @return UI::UserInput() result
 */
global define symbol RestoreOptionsDialog() ``{
    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`VSpacing(1),
		`Left(`CheckBox(`id(`lilo), _("Run &lilo after restoration"), Restore::runlilo)),
		`VSpacing(0.2),
		`Left(`CheckBox(`id(`susecfg), _("Run &SuSEconfig after restoration"), Restore::runSuSEconfig)),
		`VSpacing(0.2),
		`Left(`CheckBox(`id(`rpmdb), _("Restore RPM &database (if present in archive)"), Restore::restoreRPMdb)),
		`VSpacing(1.5)
	    ),
	    `HSpacing(2)
	);

    Wizard::ReplaceNextButton(`PushButton(`id(`next), `opt(`default), OKButtonLabel()));

    Wizard::SetContents(_("Restore options"), contents, "help", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();
    }
    while(ret != `next && ret != `abort && ret != `back);

    if (ret == `cancel)
    {
	ret = `abort;
    }
    else
    {
	Restore::runlilo = UI::QueryWidget(`id(`lilo), `Value);
	Restore::runSuSEconfig = UI::QueryWidget(`id(`susecfg), `Value);
	Restore::restoreRPMdb = UI::QueryWidget(`id(`rpmdb), `Value);
    }

    Wizard::RestoreNextButton();

    return ret;
}

/**
 * Display all files in backup archive which belong to package. User can select wqhich files will be resored.
 * @return symbol UI::UserInput() result
 */
global define symbol FileSelectionDialog(string packagename) ``{

    // create multiselection widget contents

    map pkginfo = lookup(Restore::GetArchiveInfo(), packagename, $[]);

    string sel_type = lookup(pkginfo, "sel_type", " ");
    list files = lookup(pkginfo, "files", []);
    list sel_file = lookup(pkginfo, "sel_file", []);

    list cont = [];

    foreach(string f, files, ``{
	    boolean selected = false;

	    if (sel_type == "X")
	    {
		selected = true;
	    }
	    else if (sel_type == " ")
	    {
		selected = false;
	    }
	    else if (sel_type == "P")
	    {
		selected = contains(sel_file, f);
	    }
	    else
	    {
		y2error("Unknown selection type %1 in package %2", sel_type, packagename);
	    }

	    cont = add(cont, `item(`id(f), f, selected));
	}
    );

    string mlabel = _("&Files to restore");

    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`VSpacing(1),
		`ReplacePoint(`id(`rp), `MultiSelectionBox(`id(`mbox), mlabel, cont)),
		`VSpacing(1),
		`HBox(
		    `PushButton(`id(`all), _("&Select all")),
		    `PushButton(`id(`none), _("&Deselect all"))
		),
		`VSpacing(1.5)
	    ),
	    `HSpacing(2)
	);

    Wizard::ReplaceNextButton(`PushButton(`id(`next), `opt(`default), OKButtonLabel()));

    // for translatores: %1 is name of package (e.g. "aaa_base")
    Wizard::SetContents(sformat(_("File selection - package %1"), packagename), contents, "help", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();

	if (ret == `all || ret == `none)
	{
	    cont = [];
	    boolean selected = (ret == `all);

	    foreach(string f, files, ``{
		    cont = add(cont, `item(`id(f), f, selected));
		}
	    );

	    UI::ReplaceWidget(`id(`rp), `MultiSelectionBox(`id(`mbox), mlabel, cont));
	}
	else if (ret == `cancel)
	{
	    ret = `abort;
	}
    }
    while(ret != `next && ret != `abort && ret != `back);

    if (ret == `next)
    {
	string sel_type_new = "";
	// TODO save changes
	list sel = UI::QueryWidget(`id(`mbox), `SelectedItems);

	if (size(sel) == 0)
	{
	    sel_type_new = " ";
	}
	else if (size(sel) == size(files))
	{
	    sel_type_new = "X";
	    // clear list of selected files to save memory, "X" as sel_type is enough
	    sel = [];
	}
	else
	{
	    sel_type_new = "P";
	}

	Restore::SetRestoreSelection(packagename, $["sel_type" : sel_type_new, "sel_file" : sel]);
    }

    Wizard::RestoreNextButton();

    return ret;
}

/**
 * Display content of backup archive in the table.
 * @return symbol UI::UserInput() result
 */
global define symbol ArchiveContentsDialog() ``{

    Wizard::ClearContents();

    if (archivecontentscache == nil)
    {
	archivecontentscache = CreateArchiveContentTable(Restore::GetArchiveInfo());
    }

    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`VSpacing(1),

		`Table(`id(`table), `header(_("Package"), _("File")), archivecontentscache),
		`VSpacing(1.5)
	    ),
	    `HSpacing(2)
	);

    Wizard::ReplaceNextButton(`PushButton(`id(`next), `opt(`default), OKButtonLabel()));

    Wizard::SetContents(_("Archive contents"), contents, "help", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();
    }
    while(ret != `next && ret != `abort && ret != `back);

    if (ret == `cancel)
    {
	ret = `abort;
    }

    Wizard::RestoreNextButton();

    return ret;
}

/**
 * Restore packages from backup archive - display progress of restoring process
 * @return symbol UI::UserInput() result
 */
global define symbol RestoreProgressDialog() ``{

    symbol ret = nil;
    symbol progressbar = `progress;

    term contents = `HBox(
	    `HSpacing(2),
	    `VBox(
		`VSpacing(1),
		`ProgressBar(`id(progressbar), " ", Restore::TotalFilesToRestore(), 0),
		`VSpacing(1.5)
	    ),
	    `HSpacing(2)
	);

    // callback function for abort
    block callback = ``{
	include "ui/common_messages.ycp";

	symbol ret = UI::PollInput();
	boolean abort = false;

	if (ret == `abort || ret == `cancel)
	{
	    abort = UI::AnyQuestionPopup(_("Abort confirmation"), _("Do you really want to abort restore?"), YesButtonLabel(), NoButtonLabel(), `focus_no);
	}

	return abort;
    };

    Wizard::SetContents(_("Restoring files"), contents, "help", false, false);

    // start restoration
    map result = Restore::Write(callback, progressbar, "/tmp/restore");  // TODO FIXME: unpack to "/"

    // set values from restoration
    ret = (lookup(result, "aborted", false)) ? `abort : `next;

    if (ret == `next)
    {
	 restoredfiles = lookup(result, "restored", []);
	 failedfiles = lookup(result, "failed", []);
    }

    return ret;
}

/**
 * Start Yast2 package manager
 * @return symbol UI::UserInput() result
 */
global define symbol SWsingleDialog() ``{

    // TODO:  CallModule("sw_single", ["beginner"]);

    term contents = `Label(_("Here will be sw_single dialog displayed and (un)installed packages."));

    Wizard::SetContents("", contents, "", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();
    }
    while(ret != `next && ret != `abort && ret != `back);

    if (ret == `cancel)
    {
	ret = `abort;
    }

    return ret;

    //TODO after package (un)install refresh actual installed packages (do Restore::ReadActualInstalledPackages())
}

/**
 * Start SuSEconfig
 * @return symbol UI::UserInput() result
 */
global define symbol SuSEconfigDialog() ``{

    // TODO: CallModule("inst_suseconfig", []);

    term contents = `Label(_("Here will be SuSEconfig started (optionally)."));

    Wizard::SetContents("", contents, "", true, true);

    symbol ret = nil;

    do
    {
	ret = UI::UserInput();
    }
    while(ret != `next && ret != `abort && ret != `back);

    if (ret == `cancel)
    {
	ret = `abort;
    }

    return ret;
}

/**
 * Display summary of restoration
 * @return symbol UI::UserInput() result
 */
global define symbol SummaryDialog() ``{

    string basicinfo = "<P>Number of installed packages: 3<BR>Number of uninstalled packages: 0</P><P>Total restored packages: " + restoredpackages + "<BR>Total restored files: " + size(restoredfiles) + "</P><P>Restore status: Ok</P>";

    // display failed files if any
    if (size(failedfiles) > 0)
    {
	 basicinfo = basicinfo + "<P><B>Failed files</B><BR>" + mergestring(failedfiles, "<BR>") + "</P>";
    }

    // set lilo result string
    string lilostr = _("<I>Not started</I>");

    if (lilostatus == true)
    {
	lilostr = _("Ok");
    }
    else if (lilostatus == false)
    {
	lilostr = _("<B>Failed<B>");
    }


    string extendedinfo = "<P><BR><B>Details:</B></P><P>Lilo return status: " + lilostr + "</P><P><B>Installed packages:</B><BR>dsfsd-2.5.2-2<BR>ssdgdsg-2.7.1-4<BR>qwqtrt-12.4.0-1</P><P><B>Restored files:</B><BR>" + mergestring(restoredfiles, "<BR>") + "</P>";

    return DisplaySummaryDialog(basicinfo, basicinfo + extendedinfo, "help", _("Summary of restoration"), `finish);
}


/**
 * Return content for table widget - list of backup files
 * @param packagesinfo Map $[ "packagename" : $[ "files" : ["files in the archive"] ] ]
 * @return list Table content
 */
global define list CreateArchiveContentTable(map packagesinfo) ``{
    list ret = [];
    integer num = 0;

    if (packagesinfo != nil)
    {
	foreach(string p, map info, packagesinfo, ``{
		list files = lookup(info, "files", []);

		foreach(string file, files, ``{
			ret = add(ret, `item(`id(num), p, file));
			num = num + 1;
		    }
		);
	    }
	);
    }

    return ret;
}

/**
 * Return table widget contens - files and packages selected for restoration
 * @param restoreselection Restore settings
 * @return list Table content
 */
global define list CreateTableContentsRestoreSelection(map restoreselection) ``{
    list ret = [];
    // id of item in the table
    integer num = 0;

    if (restoreselection != nil)
    {
	foreach(string p, map m, restoreselection, ``{

		string ver = lookup(m, "vers", "");
		string descr = lookup(m, "descr", "");

		string seltype = lookup(m, "sel_type", " ");

		string numfiles = "";

		if (seltype == "X")
		{
		    numfiles = _("all");
		}
		else if (seltype == " ")
		{
		    numfiles = "";
		}
		else if (seltype == "P")
		{
		    integer total = size(lookup(m, "files", []));
		    integer sel = size(lookup(m, "sel_file", []));

		    numfiles = sformat(_("%1 of %2"), sel, total);
		}
		else
		{
		    y2error("Unknown selection type: %1", seltype);
		}

		// set name for "none" package
		if (p == "")
		{
		    p = _("<none>");
		}

		ret = add(ret, `item(`id(num), seltype, numfiles, p, ver, descr));

		num = num + 1;
	    }
	);
    }

    return ret;
}

/**
 * This function should be called only once before end of client. This function
 * cleans up the system - unmounts mounted files systems.
 * @return symbol Returns symbol `next for wizard sequencer
 */

global define symbol AtExit() ``{

    // unmount file system
    Restore::Umount();

    return `next;
}

}

