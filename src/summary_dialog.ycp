/****************************************************************************

Copyright (c) 2000 - 2012 Novell, Inc.
All Rights Reserved.

This program is free software; you can redistribute it and/or
modify it under the terms of version 2 of the GNU General Public License as
published by the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, contact Novell, Inc.

To contact Novell about this file by physical or electronic mail,
you may find current contact information at www.novell.com

****************************************************************************/
/**
 * File:
 *   include/restore/summary_dialog.ycp
 *
 * Package:
 *   Restore module
 *
 * Summary:
 *   Display summary dialog.
 *
 * Authors:
 *   Ladislav Slezak <lslezak@suse.cz>
 *
 * $Id$
 *
 * Display summary dialog in wizard with optional details. Summary can be saved to file.
 *
 */

{

textdomain "restore";

import "Wizard";

import "Popup";
import "Label";
import "Directory";
import "String";

/**
 * This function removes HTML tags from input string
 * @param input Input string
 * @return string String without tags
 */

define string RemoveTags(string & ret) ``{

    map<string,string> tagmapping = $[ "BR" : "\n", "/P" : "\n", "P" : "", "B" : "", "/B" : "",
	"EM" : "", "/EM" : "", "I" : "", "/I" : "", "TT" : "", "/TT" : "",
	"/BIG" : "", "BIG" : "", "CODE" : "/CODE", "STRONG" : "", "/STRONG" : "", "PRE" : "", "/PRE" : "",
	 "LARGE" : "", "/LARGE" : "", "HR" : "", "H1" : "", "/H1" : "", "H2" : "", "/H2" : "",
	 "H3" : "", "/H3" : ""
    ];

    string tag = nil;
    string taglower = nil;

    foreach(string t, string repl, tagmapping, ``{
	    tag = "<" + t + ">";

	    while (issubstring(ret, tag))
	    {
		ret = regexpsub(ret, "(.*)" + tag + "(.*)", "\\1" + repl + "\\2");
	    }

	    taglower = tolower(tag);

	    while (issubstring(ret, taglower))
	    {
		ret = regexpsub(ret, "(.*)" + taglower + "(.*)", "\\1" + repl + "\\2");
	    }
	}
    );

    return ret;
}

/**
 * Display summary dialog with optional details, it is possible to save dialog contents to file
 * @param text Summary text
 * @param detail_text Detailed summary text
 * @param helptext Help text for wizard
 * @param label Text in label
 * @param button Label for `next button, possible values are `next (label is "Next"), `ok ("Ok") or `finish ("Finish")
 * @return symbol Id of pressed button (`next, `back, `abort)
 */

define symbol DisplaySummaryDialog(string text, string detail_text, string helptext, string label, symbol button) ``{

    term contents = `VBox(
	    `VSpacing(0.5),
	    `RichText(`id(`rt), text),
	    `VSpacing(0.5),
	    // push button label
	    `HBox(`CheckBox(`id(`details), `opt(`notify, `key_F2), _("&Show Details"), false), `HSpacing(3),
		// push button label
		`PushButton(`id(`save), _("Sa&ve to File..."))),
	    `VSpacing(1.0)
	);

    if (button == `finish)
    {
	Wizard::SetNextButton(`next, Label::FinishButton() );
    }
    else if (button == `ok)
    {
	Wizard::SetNextButton(`next, Label::OKButton() );
    }
    else if (button == `next)
    {
	Wizard::RestoreNextButton();
    }
    else
    {
	y2warning("Unknown button: %1", button);
    }

    Wizard::SetContents(label, contents, helptext, true, true);

    any ret = nil;

    do
    {
	ret = UI::UserInput();

	boolean details = (boolean) UI::QueryWidget(`id(`details), `Value);

	if (ret == `details)
	{
	    UI::ChangeWidget(`id(`rt), `Value, (details == true) ? detail_text : text);
	}
	else if (ret == `save)
	{
	    string savefile = UI::AskForSaveFileName("/", "*", _("Save Summary to File"));

	    if (savefile != "" && savefile != nil)
	    {
		// Create or empty the file
		SCR::Write(.target.string, savefile, "");

		// BNC #460674
		// Due to the very ineffective all-in-one-run function, removing HTML
		// and writing thw whole file at once takes just too much time
		//
		// Fixed by going through the summary line by line (by <BR>s)

		string tmpfile = Directory::tmpdir + "/restore_tmpfile";

		y2milestone ("Using tmpfile: %1", tmpfile);
		// Using tmpfile - there are more powerful tools for parsing text
		if (SCR::Write (.target.string, tmpfile, detail_text)) {
		    if ((integer) SCR::Execute (
			.target.bash,
			sformat ("perl -pi -e \"s/<BR>/\\n\/g;\" '%1'", String::Quote (tmpfile))
		    ) == 0) {
			detail_text = (string) SCR::Read (.target.string, tmpfile);
		    }
		}

		foreach (string one_line, splitstring (detail_text, "\n"), {
		    // <BR> == newline
		    one_line = one_line + "\n";
		    // Appending lines one by one
		    SCR::Write (.backup.file_append, [savefile, RemoveTags (one_line)]);
		});

		y2milestone("Summary saved to file: %1", savefile);
	    }
	}
	else if (ret == `cancel)
	{
	    ret = `abort;
	}
    }
    while(ret != `next && ret != `abort && ret != `back);


    Wizard::RestoreNextButton();

    return (symbol) ret;
}

}

