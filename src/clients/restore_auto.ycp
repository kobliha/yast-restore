/****************************************************************************

Copyright (c) 2000 - 2012 Novell, Inc.
All Rights Reserved.

This program is free software; you can redistribute it and/or
modify it under the terms of version 2 of the GNU General Public License as
published by the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, contact Novell, Inc.

To contact Novell about this file by physical or electronic mail,
you may find current contact information at www.novell.com

****************************************************************************/
/**
 * File:       clients/restore_auto.ycp
 * Package:    Restore module
 * Summary:    Client for autoinstallation
 * Authors:    Ladislav Slezak <lslezak@suse.cz>
 *
 * $Id$
 *
 * This is a client for autoinstallation.
 * Does not do any changes to the configuration.
 *
 */


{

textdomain "restore";

import "Popup";
import "Restore";
import "Wizard";
import "Directory";
import "FileUtils";

include "restore/ui.ycp";

/* The main () */
y2milestone("-------------------------------");
y2milestone("Restore autoinst client started");

any ret = nil;
string func = "";
map param = $[];

string filename = sformat ("%1/restore_archives_tmpfile.ycp", Directory::tmpdir);

/* Check arguments */
if (size(WFM::Args()) > 0 && is(WFM::Args(0), string))
{
    func = (string) WFM::Args(0);

    if (size(WFM::Args()) > 1 && is(WFM::Args(1), map))
    {
	param = (map) WFM::Args(1);
    }
}

y2milestone("func=%1", func);
y2milestone("param=%1", param);

/* Import data*/
if (func == "Import")
{
    ret = Restore::Import(param);
    
    if (FileUtils::Exists (filename)) {
	SCR::Execute (.target.remove, filename);
    }

    // bugzilla #199657
    SCR::Write (.target.ycp, filename, param["archives"]:[]);
}
/* create a summary */
else if (func == "Summary")
{
    ret = Restore::Summary();
}
else if (func == "Reset")
{
    ret = Restore::Import($[]);
}
else if (func == "Change")
{
    // remember settings which will be overwritten at archive selection
    Restore::Import(param);
    ret = RestoreAutoSequence();
}
else if (func == "Packages")
{
    ret = $[];
}
else if (func == "Export")
{
    ret = Restore::Export();
}
else if (func == "Write")
{
    import "Progress";

    // Read archive file
    list <string> volumes = [];
    
    // bugzilla #199657
    if (param["archives"]:[] != []) {
	y2milestone ("Some volumes set");
	volumes = param["archives"]:[];
    } else if (FileUtils::Exists (filename)) {
	y2milestone ("Reading volumes from tmpfile");
	volumes = (list <string>) SCR::Read (.target.ycp, filename);
    }

    y2milestone ("Volumes: %1", volumes);

    if (size(volumes) == 0)
    {
	ret = false;
	return ret;
    }

    boolean read = false;
    symbol ui = `dummy;

    integer index = 0;

    foreach(string volume, volumes, ``{
	y2milestone ("Scanning volume %1", volume);

	if (ui == `abort)
	{
	    ret = false;
	    return ret;
	}

	if (index == 0)
	{
	    read = Restore::Read(volume);
	}
	else
	{
	    map read_result = Restore::ReadNextVolume(volume);
	    read = (boolean)(read_result["success"]:false);
	}
	y2milestone ("Reading volume %1 returned %2", volume, read);

	if (read == false)
	{
	    // read failed, offer manual selection
	    string input = "";

	    // popup dialog text part 1
	    if (Popup::YesNo((index == 0 ? _("Archive file cannot be read.") :
		// popup dialog text part 1
		_("Archive volume cannot be read.")) +
		// popup dialog text part 2
		_("\nSelect it manually?
")) == true)
	    {
		if (index == 0)
		{
		    input = volumes[index]:"";
		}
		else
		{
		    // in selection dialog is proposed new file name, use previous one
		    input = volumes[index - 1]:"";
		}

		// select file
		Wizard::CreateDialog();		// TODO remove this ?
		Wizard::SetDesktopIcon("restore");
		ui = ArchiveSelectionDialog(index != 0, false, input);	// false = ask only for one file, others are in 'volumes'

		// ask for more volumes if they are not specified
		if (index == 0 && Restore::IsMultiVolume() == true && size(volumes) == 1)
		{
		    ui = ArchiveSelectionDialog(true, false, input);
		}

		UI::CloseDialog();		// TODO remove this ?
	    }
	    else
	    {
		ret = false;
		return ret;
	    }
	}

	index = index + 1;
    });

    // set selection
    map<string, map> selection = param["selection"]:$[];

    foreach(string package, map info, selection, ``{
	    Restore::SetRestoreSelection(package, info);
	}
    );

    Progress::off ();
    block<boolean> blck = ``{ return false; };

    map write_ret = Restore::Write( blck, nil, Restore::targetDirectory);
    Progress::on ();

    Restore::Umount();

    ret = (size(write_ret["failed"]:[]) == 0);
    return ret;
}
else if (func == "GetModified") {
    ret =  Restore::Modified();
}
else if (func == "SetModified") {
    Restore::SetModified();
}
/* unknown function */
else
{
    y2error("unknown function: %1", func);
    ret = false;
}

// umount any mounted filesystem
Restore::Umount();

/* Finish */
y2debug("ret=%1", ret);
y2milestone("Restore autoinit client finished");
y2milestone("--------------------------------");

return ret;
/* EOF */

}
