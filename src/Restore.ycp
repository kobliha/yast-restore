/**
 * File:
 *   modules/Restore.ycp
 *
 * Package:
 *   Restore module
 *
 * Summary:
 *   Data for configuration of restore, input and output functions.
 *
 * Authors:
 *   Ladislav Slezak <lslezak@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of restore.
 * Input and output routines.
 *
 */

{
    // This is "Restore" module
    module "Restore";

    import "Progress";
    import "Report";
    import "Mode";
    import "Packages";

    textdomain "restore";

    // local file name (can be on mounted file system)
    string filename = "";

    // entered file name (e.g. nfs://server:/dir/archive.tar)
    string inputname = "";

    // contents of archive
    list archivefiles = [];

    // installed packages at backup time
    map installedpkgs = $[];

    // list of installed packages
    map actualinstalledpackages = $[];

    // restoration archive and selection
    // "vers" : "version", "files" : ["files"], "prefix" : "prefix", "descr" : "description", "sel_type" : "X", "sel_file" : [""]
    map archive_info = $[];

    // information stored in archive
    string date = "";
    string hostname = "";
    string comment = "";

    boolean multivolume = false;

    // list of files
    list volumeparts = [];

    // temporary directory
    string tempdir = "";

    // mount point, stored for unmounting
    string mountpoint = "";

    /**
     * Run lilo after files are restored
     */
    global boolean runlilo = true;

    /**
     * Run SuSEconfig after files are restored
     */
    global boolean runSuSEconfig = true;

    /**
     * Rewrite RPM db - unapack /var/lib/rpm/* files from backup if present
     */
    global boolean restoreRPMdb = false;


    /**
     * Selected archive has more parts
     * @return boolen True if archive have more than one part.
     */
    global define boolean IsMultiVolume() ``{
	return multivolume;
    }

    /**
     * Return date when backup archive was created. Date is stored in archive in file info/date.
     * @return string Date
     */
    global define string GetArchiveDate() ``{
	return date;
    }

    /**
     * Return name of backup archive
     * @return string Input name file name
     */
    global define string GetInputName() ``{
	return inputname;
    }

    /**
     * Return name of backup archive
     * @return string File name
     */
    global define string GetArchiveName() ``{
	return filename;
    }

    /**
     * Return user comment stored in archive. Comment is stored in file info/comment.
     * @return string Archive comment
     */
    global define string GetArchiveComment() ``{
	return comment;
    }

    /**
     * Return host name of machine on which backup archive was created. Host name is stored in archive in file info/hostname.
     * @return string Host name
     */
    global define string GetArchiveHostname() ``{
	return hostname;
    }

    /**
     * Return map with packages installed at backup time (form is $["package name" : "version"]).
     * @return map Installed packages at backup time
     */
    global define map GetArchiveInstalledPackages() ``{
	return installedpkgs;
    }

    /**
     * Return list of files in the backup archive
     * @return list Files in the archive
     */
    global define list GetArchiveFiles() ``{
	return archivefiles;
    }


    /**
     * Return missing packages (packages which were installed at backup time, but at restore time they are not installed)
     * @return map Map $[ "packagename" : $[ "ver" : "version", "descr" : "Short description of the package"]], key description is present only if decription exists
     */
    global define map GetMissingPackages() ``{
	map ret = $[];

	GetActualInstalledPackages();

	// filter actual installed packages out
	ret = filter(string p, string v, installedpkgs, ``{
		return (haskey(actualinstalledpackages, p) != true);
	    }
	);

	// add descriptions
	ret = mapmap(string pkg, string version, ret, ``{
		string descr = (Mode::test == false) ? select(SCR::Read(.package.shortDesc, pkg), 0, "") : "";

		if (descr == nil)
		{
		    return [pkg, $["ver" : version]];
		}
		else
		{
		    return [pkg, $["ver" : version, "descr" : descr ]];
		}
	    }
	);

	return ret;
    }

    /**
     * Return extra packages (packages which are installed at restore time, but at restore time they are installed)
     * @return map Map $[ "packagename" : $[ "ver" : "version", "descr" : "Short description of the package"]], key description is present only if decription exists
     */
    global define map GetExtraPackages() ``{
	map ret = $[];

	GetActualInstalledPackages();

	// filter actual installed packages out
	ret = filter(string p, string v, actualinstalledpackages, ``{
		return (haskey(installedpkgs, p) != true);
	    }
	);

	// add descriptions
	ret = mapmap(string pkg, string version, ret, ``{
		string descr = (Mode::test == false) ? select(SCR::Read(.package.shortDesc, pkg), 0, "") : "";

		if (descr == nil)
		{
		    return [pkg, $["ver" : version]];
		}
		else
		{
		    return [pkg, $["ver" : version, "descr" : descr ]];
		}
	    }
	);

	return ret;
    }

    /**
     * Return packages which have different version at backup archive and in system
     * @return map Map $[ "packagename" : $[ "inst": "installed version", "ver" : "version at backup time, "descr" : "Short description of the package"]], key description is present only if decription exists
     */
    global define map GetMismatchedPackages() ``{
	map ret = $[];

	GetActualInstalledPackages();

	foreach(string p, string v, actualinstalledpackages, ``{
		if (haskey(installedpkgs, p) == true)
		{
		    string backupversion = lookup(installedpkgs, p, "");

		    if (backupversion != v)
		    {
			string descr = (Mode::test == false) ? select(SCR::Read(.package.shortDesc, p), 0, "") : "";

			ret = (descr != nil) ? add(ret, p, $["ver": backupversion, "inst" : v, "descr" : descr]) :
			    add(ret, p, $["ver": backupversion, "inst" : v]);
		    }
		}
	    }
	);

	return ret;
    }

    /**
     * Return installed packages. Result is cached in Restore module, so only first use takes long time
     * @return map Map $[ "packagename" : "version" ]
     */
    global define map GetActualInstalledPackages() ``{
	if (actualinstalledpackages == $[] || actualinstalledpackages == nil)
	{
	    actualinstalledpackages = ReadActualInstalledPackages();
	}

	return actualinstalledpackages;
    }


    /**
     * Read installed packages.
     * @return map Map $[ "packagename" : "version" ]
     */
    global define map ReadActualInstalledPackages() ``{
	// read info about installed packages
	map info = SCR::Read(.targetpkg.info);

	map ret = $[];

	if (info != nil)
	{
	    foreach(string name, list data, info, ``{
		    string version = select(data, 0, "");

		    ret = add(ret, name, version);
		}
	    );
	}

	return ret;
    }

    /**
     * Clear cache of installed packages. Next use of GetActualInstalledPackages() function will reread installed packages.
     */
     global define void ClearInstalledPackagesCache()
     {
	 actualinstalledpackages = nil;
     }

    /**
     * Get all restore settings - for use by autoinstallation.
     * @param settings The YCP structure to be imported.
     * @return boolean True on success
     */
    global define boolean Import (map settings) ``{
	// TODO FIXME: your code here (fill the above mentioned variables)...
	sleep (3000);
	return true;
    }

    /**
     * Dump the restore settings to a single map - for use by autoinstallation.
     * @return map Dumped settings (later acceptable by Import ())
     */
    global define map Export () ``{
	// TODO FIXME: your code here (return the above mentioned variables)...
	sleep (3000);
	return $[];
    }

    /**
     * Read contents of archive
     * @param archivefile File name of backup archive. File on NFS server is 'nfs://server:/dir/file.tar', local file: 'file:///dir/file.tar' (prefix is file://, directory is /dir)
     * @return boolean True if archive was succesfully read, otherwise false (file does not exist, not tar archive, broken archive, archive not created by Backup module, ...)
     */
    global define boolean Read(string input) ``{

	// umount old mount point
	Umount();

	if (tempdir == "")
	{
	    tempdir = SCR::Read(.target.tmpdir);
	}

	inputname = input;

	if (Mode::test == true)
	{
	    filename = "/tmp/dummy.tar";

	    archivefiles = [ "info/", "info/date", "info/comment", "info/files",
		"info/packages_info", "info/installed_packages", "info/hostname",
		"NOPACKAGE-20020509-0.tar.gz", "kdebase3-3.0-19-20020509-0.tar.gz", "lprng-3.8.5-49-20020509-0.tar.gz",
		"mozilla-0.9.8-54-20020509-0.tar.gz", "netcfg-2002.3.20-0-20020509-0.tar.gz" ];

	    date = "13.01.2002 14:25";
	    comment = "Some comments";
	    hostname = "linux.local";

	    installedpkgs = $["netcfg" : "2002.3.20-0", "lprng" : "3.8.5-49", "kdebase3" : "3.0-19", "gnome-applets" : "1.4.0.5-98", "mozilla" : "0.9.8-54"];
	    actualinstalledpackages = $["ggv" : "1.1.93-167", "netcfg" : "2002.3.20-0", "lprng" : "3.8.5-49", "kdebase3" : "3.0-19", "aterm" : "0.4.0"];

	    archive_info = $["" : $["descr" : "Files not owned by any package", "files":["/.qt/", "/dev/dvd", "/dev/cdrom"], "sel_type" : "X" ],
		"kdebase3" : $["descr" : "KDE base package: base system", "files":["/etc/opt/kde3/share/config/kdm/kdmrc"], "prefix" : "", "sel_type" : "X", "vers" : "3.0-19"],
		"mozilla" : $["descr" : "Open Source WWW browser", "files" : ["/opt/mozilla/chrome/installed-chrome.txt"], "prefix" : "", "sel_type" : "X", "vers" : "0.9.8-54"],
		"lprng" : $["descr" : "LPRng Print Spooler", "files" : ["/etc/init.d/lpd"], "prefix" : "", "sel_type" : "X", "vers" : "3.8.5-49"],
		"netcfg":$["descr" : "Network configuration files in /etc", "files" : ["/etc/HOSTNAME", "/etc/defaultdomain", "/etc/exports", "/etc/hosts"], "prefix":"", "sel_type":"X", "vers":"2002.3.20-0"]
		];

	    // set default selection
	    archive_info = mapmap(string p, map i, archive_info, ``{
		    i = add(i, "sel_type", (p == "") ? "X" : ((haskey(actualinstalledpackages, p)) ? "X" : " "));

		    return [p, i];
		}
	    );

	    return true;
	}

	//parse 'input'
	string nfsprefix = "nfs://";
	string fileprefix = "file://";
	string cdprefix = "cd";		// cd prefix can be "cd://" (equivalent to "cd0://"), "cd1://", "cd2://", ... number of CD identification

	if (substring(input, 0, size(nfsprefix)) == nfsprefix)
	{
	    string tail = substring(input, size(nfsprefix));
	    integer pos = findfirstof(tail, ":");

	    string nfs_server = substring(tail, 0, pos);
	    string nfs_file = substring(tail, pos + 1);

	    y2milestone("NFS source - server: %1  file: %2", nfs_server, nfs_file);

	    map mountresult = mountNFS(nfs_server, nfs_file);

	    if (lookup(mountresult, "mounted", false) == false)
	    {
		y2error("Cannot read source '%1' - mount failed", input);
		return false;
	    }
	    else
	    {
		mountpoint = lookup(mountresult, "mountpoint", "");
		filename = mountpoint + "/" + lookup(mountresult, "file", "");
	    }
	}
	else if (substring(input, 0, size(fileprefix)) == fileprefix)
	{
	    filename = substring(input, size(fileprefix));

	    y2milestone("FILE source: %1", filename);
	}
	else if (substring(input, 0, size(cdprefix)) == cdprefix)
	{
	    // get CD drive index
	    string cdindex = regexpsub(input, "cd([0-9]*)://(.*)", "\\1");
	    string cdfile = regexpsub(input, "cd([0-9]*)://(.*)", "\\2");

	    if (cdindex == nil || cdindex == "")
	    {
		cdindex = "0";
	    }

	    if (cdfile == nil)
	    {
		cdfile = "";
	    }

	    y2milestone("CD source - drive: %1  file: %2", cdindex, cdfile);

	    // mount CD
	    map mountresult = mountCD(tointeger(cdindex));

	    if (lookup(mountresult, "mounted", false) == false)
	    {
		y2error("Cannot read source '%1' - mount failed", input);
		return false;
	    }
	    else
	    {
		mountpoint = lookup(mountresult, "mountpoint", "");
		filename = mountpoint + "/" + cdfile;
	    }
	}
	else
	{
	    y2error("Unknown prefix in input: %1", input);
	    return false;
	}

	// get archive contents
	map result = SCR::Execute(.target.bash_output, "/bin/tar -t -f " + filename);

	// check tar exit value
	if (lookup(result, "exit", -1) != 0)
	{
	    // test if archive is multi volume - use -v parameter to get file descriptions
	    map detailresult = SCR::Execute(.target.bash_output, "/bin/tar -v -t -f " + filename);

	    list stdout = splitstring(lookup(detailresult, "stdout", ""), "\n");
	    string firstline = select(stdout, 0, "");

	    // check if there is first volume label
	    if (regexpmatch(firstline, "V--------- .* YaST2 backup: Volume 1--.*--") == true)
	    {
		// multivolume archive found - continue
		y2milestone("Found multivolume archive");
		multivolume = true;

		string tmpfile = tempdir + "/001.tar";

		// copy multi volume part to temp directory
		integer exit = SCR::Execute(.target.bash, "/bin/cp " + filename + " " + tmpfile);

		if (exit == 0)
		{
		    // set list of volumes
		    volumeparts = [ tmpfile ];

		    // read archive info from local copy (should be faster)
		    filename = tmpfile;
		}
		else
		{
		    y2error("Copy failed");
		    return false;
		}

	    }
	    else
	    {
		return false;
	    }
	}

	// get list of files
	archivefiles = splitstring(lookup(result, "stdout", ""), "\n");
	archivefiles = filter(string f, archivefiles, ``{return f != "" && f != nil;});

	if (!(contains(archivefiles, "info/files") && contains(archivefiles, "info/packages_info") && contains(archivefiles, "info/installed_packages")))
	{
	    // archive doesn't contain files from backup - file is not backup archive or not first volume of multi volume archive
	    y2error("Archive does not contain 'info/files' or 'info/packages_info' or 'info/installed_packages' file!");
	    return false;
	}

	y2debug("archivefiles: %1", archivefiles);

	string infofiles = "info/comment info/hostname info/date info/installed_packages info/files info/packages_info";

	// unpack info files
	result = SCR::Execute(.target.bash_output, "/bin/tar -C " + tempdir + " -x -f " + filename + " " + infofiles);

	date = SCR::Read(.target.string, tempdir + "/info/date");
	comment = SCR::Read(.target.string, tempdir + "/info/comment");
	hostname = SCR::Read(.target.string, tempdir + "/info/hostname");

	// read archive contents file
	string archivefs = SCR::Read(.target.string, tempdir + "/info/files");

	if (archivefs != nil)
	{
	    archivefiles = splitstring(archivefs, "\n");
	    archivefiles = filter(string pk, archivefiles, ``{return pk != "" && pk != nil;});
	}

	// read installed packages
	string installedpkgs_str = SCR::Read(.target.string, tempdir + "/info/installed_packages");

	// convert string to list
	list installedpkgs_list = splitstring(installedpkgs_str, "\n");
	installedpkgs_list = filter(string pk, installedpkgs_list, ``{return pk != "" && pk != nil;});

	// convert list to map (key - package name, value - package version)
	installedpkgs = listmap(string fullname, installedpkgs_list, ``{
		string version = regexpsub(fullname, ".*-(.*-.*)", "\\1");
		string name = substring(fullname, 0, size(fullname) - size(version) - 1);

		return [name, version];
	    }
	);

	string pkginfo_str = SCR::Read(.target.string, tempdir + "/info/packages_info");

	list pkginfo = splitstring(pkginfo_str, "\n");
	pkginfo = filter(string pk, pkginfo, ``{return pk != "" && pk != nil;});

	string actualpkg = nil;
	string actualversion = "";
	string prefix = "";
	list pkfiles = [];

	string packagestring = "Package: ";
	string nopackagestring = "Nopackage:";
	string prefixstring = "Installed: ";

	foreach(string line, pkginfo, ``{
		if (substring(line, 0, size(packagestring)) == packagestring || line == nopackagestring)
		{
		    if (actualpkg != nil)
		    {
			archive_info = add(archive_info, actualpkg, $[ "vers" : actualversion, "files" : pkfiles, "prefix" : prefix ]);
		    }

		    pkfiles = [];
		    prefix = "";

		    if (line == nopackagestring)
		    {
			actualpkg = "";
		    }
		    else
		    {
			string full = substring(line, size(packagestring));

			actualversion = regexpsub(full, ".*-(.*-.*)", "\\1");
			actualpkg = substring(full, 0, size(full) - size(actualversion) - 1);
		    }
		}
		else if (substring(line, 0, size(prefixstring)) == prefixstring)
		{
		    prefix = substring(line, size(prefixstring));

		    if (prefix == "(none)")
		    {
			prefix = "";
		    }
		}
		else if (substring(line, 0, 1) == "/")
		{
		    pkfiles = add(pkfiles, line);
		}
		else
		{
		    y2error("Unknown line in file packages_info: %1", line);
		}
	    }
	);

	// add last package info
	if (actualpkg != nil)
	{
	    archive_info = add(archive_info, actualpkg, $[ "files" : pkfiles, "prefix" : prefix ]);
	}

	// read actual installed packages

	GetActualInstalledPackages();

	map mismatched = GetMismatchedPackages();

	// add package descriptions and default selection
	archive_info = mapmap(string p, map i, archive_info, ``{
		string descr = (p == "") ? _("Files not owned by any package") : select(SCR::Read(.package.shortDesc, p), 0, "");
		map t = add(i, "descr", descr);

		string sel_type = " ";

		// set default selection to "X" (package is installed) or " " (package is not installed)
		if (p == "")
		{
		    // set "no package" default value to "X"
		    sel_type = "X";
		}
		else
		{
		    sel_type = (haskey(actualinstalledpackages, p) && !haskey(mismatched, p)) ? "X" : " ";
		}

		t = add(t, "sel_type", sel_type);

		return [p, t];
	    }
	);

	y2milestone("values from archive: date=%1, comment=%2, hostname=%3", date, comment, hostname);

	y2debug("installed packages at backup time: %1", installedpkgs);
	y2debug("actual installed packages: %1", GetActualInstalledPackages());

	return true;
    }


    /**
     * Return restore configuration
     * @return map Map $[ "packagename" : $["vers" : "version", "files" : ["files in the archive"], "prefix" : "installprefix", "descr" : "Short description", "sel_type" : "X", "sel_file" : ["selected files to restore"] ] ], possible values for "sel_type" key are: "X" - restore all files from archive, " " - do not restore this package, "P" - partial restore, restore only selected files at "sel_file" key. Package name "" means files not owned by any package.
     */
    global define map GetArchiveInfo() ``{
	return archive_info;
    }

    /**
     * Change restore selection of package.
     * @param pkgname Name of package
     * @param selection New restore selection for package, map  $[ "sel_type" : "X", "sel_file" : ["files"] ]
     */
    global define void SetRestoreSelection(string pkgname, map selection) ``{
	if (haskey(archive_info, pkgname) == false)
	{
	    y2warning("Package %1 is not in archive, cannot be restored!", pkgname);
	}
	else
	{
	    string sel_type = lookup(selection, "sel_type", " ");
	    list sel_file = [];
	    map pkginfo = lookup(archive_info, pkgname, $[]);

	    if (sel_type == "P")
	    {
		sel_file = lookup(selection, "sel_file", []);
	    }
	    else if (sel_type != "X" && sel_type != " ")
	    {
		y2warning("Unknown selection type '%1' for package '%2'", sel_type, pkgname);
	    }

	    pkginfo = add(pkginfo, "sel_type", sel_type);
	    pkginfo = add(pkginfo, "sel_file", sel_file);

	    archive_info = add(archive_info, pkgname, pkginfo);
	}
    }

    /**
     * Constructor: initialize targetpkg agent using Packages module
     */
    global define void Restore() ``{
	// false = no force, do not reset previous package selection
	if (Mode::test == false)
	{
	    Packages::Init(false);
	}
    }

    /**
     * Return number of files which will be unpacked from archive
     * @return integer Total selected files
     */
    global define integer TotalFilesToRestore() ``{
	integer total = 0;

	// filter out unselected packages and compute total restored files
	foreach(string p, map info, archive_info, ``{
		string sel_type = lookup(info, "sel_type", " ");

		if (sel_type == "X")
		{
		    total = total + size(lookup(info, "files", []));
		}
		else if (sel_type == "P")
		{
		    total = total + size(lookup(info, "sel_file", []));
		}
	    }
	);

	return total;
    }

    /**
     * Restore files from archive
     * @param abort This block is periodically evaluated, if it evaluates to true restoration will be aborted. It should be something like ``{return UI::PollInput () == `abort;} if UI exists or ``{ return false; } if there is no UI (abort will not be possible).
     * @param progress Id of progress bar or nil.
     * @param targetdir Directory to which files from archive will be upacked
     * @return map Map $[ "aborted" : boolean, "restored" : [ "restored file" ], "failed" : [ "failed file" ] ]
     */

    global define map Write(block abort, symbol progress, string targetdir) ``{

	map restore = archive_info;
	integer total = 0;
	integer restored = 0;
	integer restoredpackages = 0;
	list restoredfiles = [];
	list failedfiles = [];
	boolean aborted = false;

	// filter out unselected packages and compute total restored files
	restore = filter(string p, map info, restore, ``{
		string sel_type = lookup(info, "sel_type", " ");

		if (sel_type == "X")
		{
		    total = total + size(lookup(info, "files", []));
		    return true;
		}
		else if (sel_type == "P")
		{
		    total = total + size(lookup(info, "sel_file", []));
		    return true;
		}
		else
		{
		    return false;
		}
	    }
	);

	y2milestone("%1 files will be restored from archive", total);

	// get list of all packages to restore (while cycle is used, because foreach cannot be stopped)
	list packages = [];
	foreach(string package, map info, restore, ``{
		packages = add(packages, package);
	    }
	);

	integer i = 0;
	symbol ret = `next;

	while (i < size(packages))
	{
	    string package = select(packages, i, "nonexistingpackage");
	    map info = lookup(restore, package, $[]);
	    string label = (package == "") ? _("Restoring files not owned by any package ...") : sformat(_("Restoring package %1 ..."), package);
	    string sel_type = lookup(info, "sel_type", "");

	    if (progress != nil)
	    {
		// update name of package
		UI::ChangeWidget(`id(progress), `Label, label);
	    }

	    if (Mode::test == true)
	    {
		// "unpacking" in test mode
		integer numf = (sel_type == "P") ? size(lookup(info, "sel_file", [])) : size(lookup(info, "files", []));

		while (numf > 0)
		{
		    restored = restored + 1;

		    if (progress != nil)
		    {
			UI::ChangeWidget(`id(progress), `Value, restored);
		    }

		    sleep(300);
		    numf = numf - 1;
		}
	    }
	    else
	    {
		// get subarchive name
		string name = (package == "") ? "NOPACKAGE" : package + "-" + lookup(info, "vers", "");
		string fileinarchive = "";

		foreach(string f, archivefiles, ``{
			if (regexpmatch(f, "^" + name + "-........-.\\.tar.*") == true)
			{
			    y2debug("package %1 is in archive file %2", package, f);
			    fileinarchive = f;
			}
		    }
		);

		if (fileinarchive == "")
		{
		    y2error("Can't find subarchive for package %1", package);
		}
		else
		{
		    // unpack subarchive at background
		    boolean started  = SCR::Execute(.background.run, "export LC_ALL=C; /bin/tar -C " + tempdir + " -x -f " + filename + " " + fileinarchive);

		    // abort test cycle
		    while(SCR::Read(.background.isrunning))
		    {
			sleep(100);

			aborted = eval(abort);

			if (aborted == true)
			{
			    y2warning("Restoration aborted!");
			    SCR::Execute(.background.kill, nil);	// kill subprocess
			    break;
			}
		    }

		    // break all packages cycle
		    if (aborted == true)
		    {
			break;
		    }

		    // set compression parameter
		    string compress = "";
		    if (regexpmatch(fileinarchive, ".*\.tar\.gz$") == true)
		    {
			compress = "-z";
		    }
		    else if (regexpmatch(fileinarchive, ".*\.tar\.bz2$") == true)
		    {
			compress = "-j";
		    }

		    string RPMdb = (restoreRPMdb) ? "" : "--exclude var/lib/rpm";

		    // files to unpack, "" means all files
		    string unpackfiles = "";

		    // select files to unpack
		    if (sel_type == "P")
		    {
			// strip leading '/'
			foreach(string f, lookup(info, "sel_file", []), ``{
				if (size(f) > 1 && substring(f, 0, 1) == "/")
				{
				    unpackfiles = unpackfiles + " " + substring(f, 1);
				}
			    }
			);
		    }

		    // start subprocess
		    started = SCR::Execute(.background.run_output, "export LC_ALL=C; /bin/tar -C " + targetdir + " " + compress + " -x -v -f " + tempdir + "/" + fileinarchive + " " + RPMdb + " " + unpackfiles + " 2> " + tempdir + "/tar.stderr");

		    while(SCR::Read(.background.output_open) || (SCR::Read(.background.newlines) > 0))
		    {
			restored = restored + SCR::Read(.background.newlines);

			// read output from tar
			restoredfiles = merge(restoredfiles, SCR::Read(.background.newout));

			// update progressbar
			if (progress != nil)
			{
			    UI::ChangeWidget(`id(progress), `Value, restored);
			}

			while (SCR::Read(.background.newlines) == 0 && SCR::Read(.background.output_open))
			{
			    sleep(100);	// small delay

			    aborted = eval(abort);

			    if (aborted == true)
			    {
				y2warning("Restoration aborted!");
				SCR::Execute(.background.kill, nil);	// kill subprocess
				break;
			    }
			}

			if (aborted == true)
			{
			    break;
			}

		    }

		    if (aborted == true)
		    {
			break;
		    }

		    // read failedfiles
		    list stderr =  splitstring(SCR::Read(.target.string, tempdir + "/tar.stderr"), "\n");
		    integer packagefailedfiles = 0;

		    if (stderr != [])
		    {
			y2warning("stderr: %1", stderr);
		    }

		    // add file names to failedfiles
		    foreach(string line, stderr, ``{
			    y2warning("line: %1", line);

			    if (line != nil && line != "")
			    {
				string file = regexpsub(line, "tar: (.*):.*:.*", "\\1");

				if (file != nil)
				{
				    add(failedfiles, file);
				    packagefailedfiles = packagefailedfiles + 1;

				    y2warning("Restoration of file %1 failed", file);
				}
			    }
			}
		    );

		    // package restoration failed
		    if (packagefailedfiles == size(restoredfiles))
		    {
			y2warning("failed package: %1", package);
		    }
		    else
		    {
			restoredpackages = restoredpackages + 1;
		    }
		}
	    }

	    i = i + 1;
	}

	// sort list of restored files and remove duplicates (caused by multiple unpacking)
	restoredfiles = toset(restoredfiles);

	// remove failed files
	restoredfiles = filter(string f, restoredfiles, ``{
		return !contains(failedfiles, f);
	    }
	);

	y2milestone("restored files: %1", restored);

	return $[ "aborted" : aborted, "restored" : restoredfiles, "failed" : failedfiles ];
    }


    /**
     * Start lilo if requested.
     * @return map Map $[ "lilo" : integer exit_value, "stderr" : [ "stderr lines" ] ] or $[ "lilo" : nil ] if lilo was not started
     */
    global define map Lilo() ``{
	if (runlilo == true)
	{
	    // start lilo
	    map ret  = SCR::Execute(.target.bash_output, "/sbin/lilo");
	    return $[ "lilo" : lookup(ret, "exit", -1), "stderr" : splitstring(lookup(ret, "stderr", ""), "\n") ];
	}
	else
	{
	    // lilo was not used
	    return $[ "lilo" : nil ];
	}
    }



    define map mountNFS(string server, string file) ``{
	integer pos = findlastof(file, "/");

	if (pos != nil)
	{
	    string dir = substring(file, 0, pos);
	    string f = substring(file, pos + 1);

	    string tmpdir = SCR::Read(.target.tmpdir);
	    string mpoint = tmpdir + "/nfs";

	    if (dir == "" || dir == nil)
	    {
		dir = "/";
	    }

	    // create mount point directory
	    SCR::Execute(.target.mkdir, mpoint);

	    y2milestone("dir: %1", dir);
	    y2milestone("file: %1", f);

	    boolean result = SCR::Execute(.target.mount, [server + ":" + dir, mpoint], "-t nfs");

	    return $[ "mounted" : result, "mountpoint" : mpoint , "file" : f, "server_dir" : dir ];
	}

	return $[ "mounted" : false ];
    }


    global define map mountCD(integer cdindex) ``{
	list drives = SCR::Read(.probe.cdrom);

	if (cdindex == nil || cdindex > size(drives) - 1)
	{
	    return $[ "mounted" : false ];
	}

	string cddevice = lookup(select(drives, cdindex, $[]), "dev_name", "/dev/cdrom");
	string tmpdir = SCR::Read(.target.tmpdir);
	string mpoint = tmpdir + "/cd";

	// create mount point directory
	SCR::Execute(.target.mkdir, mpoint);

	boolean result = SCR::Execute(.target.mount, [cddevice, mpoint] );

	return $[ "mounted" : result, "mountpoint" : mpoint ];
    }


    /**
     * Umount mounted file system.
     */

    global define void Umount() ``{
	y2debug("Umount() called");

	if (mountpoint != "" && mountpoint != nil)
	{
	    SCR::Execute(.target.umount, mountpoint);
	}
    }


}

