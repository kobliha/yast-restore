/**
 * File:
 *   modules/Restore.ycp
 *
 * Package:
 *   Restore module
 *
 * Summary:
 *   Data for configuration of restore, input and output functions.
 *
 * Authors:
 *   Ladislav Slezak <lslezak@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of restore.
 * Input and output routines.
 *
 */

{
    // Set the name of the module
    module "Restore";
    import "Progress";
    import "Report";
    import "Mode";

    import "Packages";

    textdomain "restore";


    string filename = "";
    // contents of archive
    list archivefiles = [];

    // installed packages at backup time
    map installedpkgs = $[];

    // list of installed packages
    map actualinstalledpackages = $[];

    // restoration archive and selection
    // "vers" : "version", "files" : ["files"], "prefix" : "prefix", "descr" : "description", "sel_type" : "X", "sel_file" : [""]
    map archive_info = $[];

    // information stored in archive
    string date = "";
    string hostname = "";
    string comment = "";

    boolean multiarchive = false;

    string tempdir = "";

    // restore options:
    global boolean runlilo = true;
    global boolean runSuSEconfig = true;
    global boolean restoreRPMdb = false;

    global define boolean IsMultiArchive() ``{
	return multiarchive;
    }

    global define string GetArchiveDate() ``{
	return date;
    }

    global define string GetArchiveName() ``{
	return filename;
    }

    global define string GetArchiveComment() ``{
	return comment;
    }

    global define string GetArchiveHostname() ``{
	return hostname;
    }

    global define list GetArchiveInstalledPackages() ``{
	return installedpkgs;
    }

/*    global define list GetNotDistributedPackages() ``{
	return [];
    }
*/
    global define map GetMissingPackages() ``{
	map ret = $[];

	if (actualinstalledpackages == $[])
	{
	    actualinstalledpackages = ReadActualInstalledPackages();
	}

	// filter actual installed packages out
	ret = filter(string p, string v, installedpkgs, ``{
		return (haskey(actualinstalledpackages, p) != true);
	    }
	);

	// add descriptions
	ret = mapmap(string pkg, string version, ret, ``{
		string descr = (Mode::test == false) ? select(SCR::Read(.package.shortDesc, pkg), 0, "") : "";

		if (descr == nil)
		{
		    return [pkg, $["ver" : version]];
		}
		else
		{
		    return [pkg, $["ver" : version, "descr" : descr ]];
		}
	    }
	);

	return ret;
    }

    global define map GetExtraPackages() ``{
	map ret = $[];

	if (actualinstalledpackages == $[])
	{
	    actualinstalledpackages = ReadActualInstalledPackages();
	}

	// filter actual installed packages out
	ret = filter(string p, string v, actualinstalledpackages, ``{
		return (haskey(installedpkgs, p) != true);
	    }
	);

	// add descriptions
	ret = mapmap(string pkg, string version, ret, ``{
		string descr = (Mode::test == false) ? select(SCR::Read(.package.shortDesc, pkg), 0, "") : "";

		if (descr == nil)
		{
		    return [pkg, $["ver" : version]];
		}
		else
		{
		    return [pkg, $["ver" : version, "descr" : descr ]];
		}
	    }
	);

	return ret;
    }

    // package name: $["inst": actual, "ver : "at backup time, "descr" : package description]
    global define map GetMismatchedPackages() ``{
	map ret = $[];

	if (actualinstalledpackages == $[])
	{
	    actualinstalledpackages = ReadActualInstalledPackages();
	}

	foreach(string p, string v, actualinstalledpackages, ``{
		if (haskey(installedpkgs, p) == true)
		{
		    string backupversion = lookup(installedpkgs, p, "");

		    if (backupversion != v)
		    {
			string descr = (Mode::test == false) ? select(SCR::Read(.package.shortDesc, p), 0, "") : "";

			ret = (descr != nil) ? add(ret, p, $["ver": backupversion, "inst" : v, "descr" : descr]) :
			    add(ret, p, $["ver": backupversion, "inst" : v]);
		    }
		}
	    }
	);

	return ret;
    }

    global define map GetActualInstalledPackages() ``{
	if (actualinstalledpackages == $[] || actualinstalledpackages == nil)
	{
	    actualinstalledpackages = ReadActualInstalledPackages();
	}

	return actualinstalledpackages;
    }

    global define map ReadActualInstalledPackages() ``{
	// read info about installed packages
	map info = SCR::Read(.targetpkg.info);

	map ret = $[];

	if (info != nil)
	{
	    foreach(string name, list data, info, ``{
		    string version = select(data, 0, "");

		    ret = add(ret, name, version);
		}
	    );
	}

	return ret;
    }


    /**
     * Read all restore settings from the SCR
     * @param abort A block that can be called by Read to find
     *	      out whether abort is requested. Returns true if abort
     *	      was pressed.
     * @return boolean True on success
     */
    global define boolean Read (block abort) ``{
	boolean read_aborted = false;

	// TODO FIXME Assign the true texts intead of these
	string caption = _("Initializing restore configuration");
	// TODO FIXME Set the right number of stages
	integer no_of_steps = 4;

	// TODO FIXME Names of real stages
	// We do not set help text here, because it was set outside
	Progress::New ( caption, " ", no_of_steps,
		       [ _("Read the database"),
			 _("Read the previous settings"),
			 _("Detect the devices") ],
		       [ _("Reading the database..."),
			 _("Reading the previous settings..."),
			 _("Detecting the devices..."),
			 _("Finished") ],
		       "" );

	// TODO FIXME: your code here (fill the above mentioned variables)...

	// read database
	Progress::NextStage ();
	read_aborted = eval (abort);
	if (read_aborted)
	{
	    return !read_aborted;
	}
	sleep (500);	// TODO FIXME remove all sleep()
	if (false)	// TODO FIXME read db1 here e.g. if (!SCR::Read (.path.db1))
	{
	    Report::Error (_("Can not read the database1!"));
	}

	// read another database
	Progress::NextStep ();
	read_aborted = eval (abort);
	if (read_aborted)
	{
	    return !read_aborted;
	}
	sleep (500);
	if (false)	// TODO FIXME read db2 here e.g. if (!SCR::Read(.path.db2))
	{
	    Report::Error (_("Can not read the database2"));
	}

	// read current settings
	Progress::NextStage ();
	read_aborted = eval (abort);
	if (read_aborted)
	{
	    return !read_aborted;
	}
	sleep (500);
	if (false)	// TODO FIXME read settings here e.g. if (!SCR::Read(.path.settings))
	{
	    Report::Error (_("Can not read current settings!"));
	}

	// detect devices
	Progress::NextStage ();
	read_aborted = eval (abort);
	if (read_aborted)
	{
	    return !read_aborted;
	}
	sleep (500);
	if (false)	// TODO FIXME detect devices here e.g. if (SCR::Read(.probe.device) == nil)
	{
	    Report::Warning (_("Can not detect device"));
	}

	// increase the progress to "finish"
	Progress::NextStage ();

	return !read_aborted;
    }

    /**
     * Update the SCR according to restore settings
     * @param abort A block that can be called by Write to find
     *	      out whether abort is requested. Returns true if abort
     *	      was pressed.
     * @return boolean True on success
     */
    global define boolean Write (block abort) ``{
	boolean write_aborted = false;
	// TODO FIXME Assign the true texts intead of these
	string caption = _("Saving restore configuration");
	// TODO FIXME And set the right number of stages
	integer no_of_steps = 2;

	// TODO FIXME Names of real stages
	// We do not set help text here, because it was set outside
	Progress::New ( caption, " ", no_of_steps,
		       [ _("Write the settings"),
			 _("Run SuSEconfig") ],
		       [ _("Writing the settings..."),
			 _("Running SuSEconfig..."),
			 _("Finished") ],
		       "" );

	// TODO FIXME: your code here (store the above mentioned variables)...

	// write settings
	Progress::NextStage ();
	write_aborted = eval (abort);
	if (write_aborted)
	{
	    return !write_aborted;
	}
	sleep (500);
	if (false)	// TODO FIXME write setting here e.g. if (!SCR::Write(.path.settings, settings))
	{
	    Report::Error (_("Can not write settings!"));
	}

	// run SuSEconfig
	Progress::NextStage ();
	write_aborted = eval (abort);
	if (write_aborted)
	{
	    return !write_aborted;
	}
	sleep (500);
	if (false)	// TODO FIXME run SuSE config e.g. if (SCR::Execute(.target.bash, "/sbin/SuSEconfig") != 0)
	{
	    Report::Error (_("SuSEconfig script failed!"));
	}

	// increase the progress to "finish"
	Progress::NextStage ();

	return !write_aborted;
    }

    /**
     * Get all restore settings from the first parameter
     * (For use by autoinstallation.)
     * @param settings The YCP structure to be imported.
     * @return boolean True on success
     */
    global define boolean Import (map settings) ``{
	// TODO FIXME: your code here (fill the above mentioned variables)...
	sleep (3000);
	return true;
    }

    /**
     * Dump the restore settings to a single map
     * (For use by autoinstallation.)
     * @return map Dumped settings (later acceptable by Import ())
     */
    global define map Export () ``{
	// TODO FIXME: your code here (return the above mentioned variables)...
	sleep (3000);
	return $[];
    }

    /**
     * Build a textual summary that can be used e.g. in inst_hw_config () or
     * something similar.
     * @return string Summary of the configuration.
     */
    global define string Summary () ``{
	// TODO FIXME: your code here...
	return _("Summary of the configuration...");
    }

    global define boolean ReadArchiveFile(string archivefile) ``{

	if (Mode::test == true)
	{
	    filename = archivefile;

	    archivefiles = [ "info/", "info/date", "info/comment", "info/files",
		"info/packages_info", "info/installed_packages", "info/hostname",
		"NOPACKAGE-20020509-0.tar.gz", "kdebase3-3.0-19-20020509-0.tar.gz", "lprng-3.8.5-49-20020509-0.tar.gz",
		"mozilla-0.9.8-54-20020509-0.tar.gz", "netcfg-2002.3.20-0-20020509-0.tar.gz" ];

	    date = "13.01.2002 14:25";
	    comment = "Some comments";
	    hostname = "linux.local";

	    installedpkgs = $["netcfg" : "2002.3.20-0", "lprng" : "3.8.5-49", "kdebase3" : "3.0-19", "gnome-applets" : "1.4.0.5-98"];
	    actualinstalledpackages = $["ggv" : "1.1.93-167", "netcfg" : "2002.3.20-0", "lprng" : "3.8.5-49", "kdebase3" : "3.0-19", "aterm" : "0.4.0"];

	    archive_info = $["" : $["descr" : "Files not owned by any package", "files":["/.qt/", "/dev/dvd", "/dev/cdrom"], "sel_type" : "X" ],
		"kdebase3" : $["descr" : "KDE base package: base system", "files":["/etc/opt/kde3/share/config/kdm/kdmrc"], "prefix" : "", "sel_type" : "X", "vers" : "3.0-19"],
		"mozilla" : $["descr" : "Open Source WWW browser", "files" : ["/opt/mozilla/chrome/installed-chrome.txt"], "prefix" : "", "sel_type" : "X", "vers" : "0.9.8-54"],
		"lprng" : $["descr" : "LPRng Print Spooler", "files" : ["/etc/init.d/lpd"], "prefix" : "", "sel_type" : "X", "vers" : "3.8.5-49"],
		"netcfg":$["descr" : "Network configuration files in /etc", "files" : ["/etc/HOSTNAME", "/etc/defaultdomain", "/etc/exports", "/etc/hosts"], "prefix":"", "sel_type":"X", "vers":"2002.3.20-0"]
		];

	    // set default selection
	    archive_info = mapmap(string p, map i, archive_info, ``{
		    i = add(i, "sel_type", (p == "") ? "X" : ((haskey(actualinstalledpackages, p)) ? "X" : " "));

		    return [p, i];
		}
	    );

	    return true;
	}
	// get archive contents
	// TODO use -v flag, filter out Volume label, set multiarchive flag
	map result = SCR::Execute(.target.bash_output, "/bin/tar -t -f " + archivefile);

	// TODO: result from multiarchive is 2!
	if (lookup(result, "exit", -1) != 0)
	{
	    // test if archive is multi volume
	    return false;
	}

	// set file name
	filename = archivefile;

	// get list of files, TODO: multivolume archive
	archivefiles = splitstring(lookup(result, "stdout", ""), "\n");
	archivefiles = filter(string f, archivefiles, ``{return f != "" && f != nil;});

	if (!contains(archivefiles, "info/files"))
	{
	    // TODO: multi volume - error, cannot get archive contents
	    y2warning("Archive does not contain 'info/files' file!");
	}

	y2milestone("archivefiles: %1", archivefiles);

	string infofiles = "info/comment info/hostname info/date info/installed_packages info/files info/packages_info";

	if (tempdir == "")
	{
	    tempdir = SCR::Read(.target.tmpdir);
	}

	// unpack info files
	result = SCR::Execute(.target.bash_output, "/bin/tar -C " + tempdir + " -x -f " + filename + " " + infofiles);

	date = SCR::Read(.target.string, tempdir + "/info/date");
	comment = SCR::Read(.target.string, tempdir + "/info/comment");
	hostname = SCR::Read(.target.string, tempdir + "/info/hostname");

	// read archive contents file
	string archivefs = SCR::Read(.target.string, tempdir + "/info/files");

	if (archivefs != nil)
	{
	    archivefiles = splitstring(archivefs, "\n");
	    archivefiles = filter(string pk, archivefiles, ``{return pk != "" && pk != nil;});
	}

	// read installed packages
	string installedpkgs_str = SCR::Read(.target.string, tempdir + "/info/installed_packages");

	// convert string to list
	list installedpkgs_list = splitstring(installedpkgs_str, "\n");
	installedpkgs_list = filter(string pk, installedpkgs_list, ``{return pk != "" && pk != nil;});

	// convert list to map (key - package name, value - package version)
	installedpkgs = listmap(string fullname, installedpkgs_list, ``{
		string version = regexpsub(fullname, ".*-(.*-.*)", "\\1");
		string name = substring(fullname, 0, size(fullname) - size(version) - 1);

		return [name, version];
	    }
	);

	string pkginfo_str = SCR::Read(.target.string, tempdir + "/info/packages_info");

	list pkginfo = splitstring(pkginfo_str, "\n");
	pkginfo = filter(string pk, pkginfo, ``{return pk != "" && pk != nil;});

	string actualpkg = nil;
	string actualversion = "";
	string prefix = "";
	list pkfiles = [];

	string packagestring = "Package: ";
	string nopackagestring = "Nopackage:";
	string prefixstring = "Installed: ";

	foreach(string line, pkginfo, ``{
		if (substring(line, 0, size(packagestring)) == packagestring || line == nopackagestring)
		{
		    if (actualpkg != nil)
		    {
			archive_info = add(archive_info, actualpkg, $[ "vers" : actualversion, "files" : pkfiles, "prefix" : prefix ]);
		    }

		    pkfiles = [];
		    prefix = "";

		    if (line == nopackagestring)
		    {
			actualpkg = "";
		    }
		    else
		    {
			string full = substring(line, size(packagestring));

			actualversion = regexpsub(full, ".*-(.*-.*)", "\\1");
			actualpkg = substring(full, 0, size(full) - size(actualversion) - 1);
		    }
		}
		else if (substring(line, 0, size(prefixstring)) == prefixstring)
		{
		    prefix = substring(line, size(prefixstring));

		    if (prefix == "(none)")
		    {
			prefix = "";
		    }
		}
		else if (substring(line, 0, 1) == "/")
		{
		    pkfiles = add(pkfiles, line);
		}
		else
		{
		    y2error("Unknown line in file packages_info: %1", line);
		}
	    }
	);

	// add last package info
	if (actualpkg != nil)
	{
	    archive_info = add(archive_info, actualpkg, $[ "files" : pkfiles, "prefix" : prefix ]);
	}

	// read actual installed packages
        if (actualinstalledpackages == $[] || actualinstalledpackages == nil)
	{
	    actualinstalledpackages = ReadActualInstalledPackages();
	}

	// add package descriptions and default selection
	archive_info = mapmap(string p, map i, archive_info, ``{
		string descr = (p == "") ? _("Files not owned by any package") : select(SCR::Read(.package.shortDesc, p), 0, "");
		map t = add(i, "descr", descr);

		string sel_type = " ";

		// set default selection to "X" (package is installed) or " " (package is not installed)
		if (p == "")
		{
		    // set "no package" default value to "X"
		    sel_type = "X";
		}
		else
		{
		    sel_type = (haskey(actualinstalledpackages, p)) ? "X" : " ";
		}

		t = add(t, "sel_type", sel_type);

		return [p, t];
	    }
	);

	y2milestone("values from archive: date=%1, comment=%2, hostname=%3", date, comment, hostname);

	y2debug("installed packages at backup time: %1", installedpkgs);
	y2debug("actual installed packages: %1", GetActualInstalledPackages());

	return true;
    }


    global define map GetArchiveInfo() ``{
	return archive_info;
    }


    global define void SetRestoreSelection(string pkgname, map selection) ``{
	if (haskey(archive_info, pkgname) == false)
	{
	    y2warning("Package %1 is not in archive, cannot be restored!", pkgname);
	}
	else
	{
//"vers" : actualversion, "files" : [pkfiles], "prefix" : prefix, "descr", "sel_type" : "X", "sel_file" : []
	    string sel_type = lookup(selection, "sel_type", " ");
	    list sel_file = [];
	    map pkginfo = lookup(archive_info, pkgname, $[]);

	    if (sel_type == "P")
	    {
		sel_file = lookup(selection, "sel_file", []);
	    }
	    else if (sel_type != "X" && sel_type != " ")
	    {
		y2warning("Unknown selection type '%1' in package %2", sel_type, pkgname);
	    }

	    pkginfo = add(pkginfo, "sel_type", sel_type);
	    pkginfo = add(pkginfo, "sel_file", sel_file);

	    archive_info = add(archive_info, pkgname, pkginfo);
	}
    }


    global define void Restore() ``{
	// false = no force, do not reset previous package selection
	if (Mode::test == false)
	{
	    Packages::Init(false);
	}
    }

}
